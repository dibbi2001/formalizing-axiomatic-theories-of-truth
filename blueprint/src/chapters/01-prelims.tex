\chapter{Preliminaries}
Section \ref{subsec:notation} will first provide some notes on notation. Then, Section \ref{subsec:language} will focus on the concepts of a first-order language and formulas, Section \ref{subsec:coding} will focus on how formulas can be encoded in natural numbers, Section \ref{subsec:lpa-lt} will discuss the specific languages of $\mathcal{L}$ and $\mathcal{L}_T$, Section \ref{subsec:axiomatization} discusses the axioms of \texttt{PA}, \texttt{PAT} and \texttt{TB}, Section \ref{subsec:proof-theory} will provide the necessary concepts for reasoning about derivations and finally Section \ref{subsec:disquotation} will discuss the concepts and final proof of the conservativity of \texttt{TB} over \texttt{PA}.

\section{Notation}\label{subsec:notation}
We aim to make this exposition intuitive for those not specialized in type theory. Hence, we will present the formal specification of the concepts in such a way that they are on the one hand as suggestive for their Lean implementation as possible while at the same time being stated in set theoretic terms rather than type theoretic ones. This made possible by an intuitive correspondence between types and sets (see e.g. \cite{nederpelt:1994}).

Moreover, as Lean has additional functionalities on top of its type theoretic basis to allow for efficient programming and proof verification, some limitations arise preventing the code from following exactly the common conceptualizations of set theoretic mathematics. The most notable of these deviations is that the symbol \texttt{0} in Lean has a reserved meaning, namely \texttt{Nat.zero}, an inhabitant of the primitive type \texttt{Nat}, describing the natural numbers. As we shall also define a language involving the concept of zero, we will hence name it \texttt{null}.

To allow for efficient automatic formulas manipulation, variables bound by a quantifier are associated with De Bruijn \cite{bruijn:1972} indices in \texttt{mathlib}'s implementation of first-order formulas. These indices are natural numbers that correspond to the level-distance between the variable and the quantifier that binds it. Take as an example the regular first-order formula 
\begin{align}
    \forall x (\forall y (P(y) \to R(f(x))) \to (R(z) \to P(a))),
\end{align} where $x, y$ are bound variables, $z$ is a free variables, $P$ and $R$ are predicates and $a$ is a constant.
In De Bruijn notation this formula is expressed by
\begin{align}\label{fml:db}
    \forall (\forall (P(0) \to R(f(1))) \to (R(1) \to P(a))).
\end{align}
Troughout this chapter we will use this formula as illustration to the concepts introduced.

\section{Language}\label{subsec:language}
The ordinary definition of a first-order language $\mathcal{L}$ proceeds from the specification of a signature $\mathcal{S}$ and then an inductive definition of the way formulas can be build with elements from $\mathcal{S}$, the set of logical connectives, variables and the quantifiers. See that for any first order language all these elements except the signature are the same. Hence, we could think of a specific first order language as being fully specified by its signature.

\begin{definition}[First-order Language]\label{def:FO-Language}
\lean{FirstOrder.Language}\leanok
  A language is a structure $\langle(F_i)_{i\in \mathbb{N}}, (R_i)_{i\in \mathbb{N}})\rangle$, where $F_i$ is a set of $i$-ary function symbols and $R_i$ a set of $i$-ary predicate symbols.
\end{definition}

Note that this defines a language as consisting only of functions and relations, whereas in philosophical logic it is more conventional that a language also contains a set of constants, like in Negri \& Von Plato \cite{negri:2001}. Observe, however, that constants can be modeled as $0$-ary functions, so this definition of a language does not limit expressive power. By providing concrete sets of function and relation symbols to $F_i$ and $R_i$ we obtain a specific language. So, the language in which our formula \ref{fml:db} is stated can be defined as $\mathcal{L}_{ex} = \langle (F_{ex,i})_{i \in \mathbb{N}}, (R_{ex,i})_{i \in \mathbb{N}} \rangle$, where $(F_{ex,i})_{i \in \mathbb{N}}$ is defined by $F_{ex,0} = \{a\}$ and $F_{ex,1} = \{f\}$ and $(R_{ex,i})_{i \in \mathbb{N}}$ is defined by $R_{ex,1} = \{P, R\}$.

Now, we can use these specifications in \texttt{mathlib}'s implementation of \texttt{Term}s and \texttt{BoundedFormula}s.

\begin{definition}[First-order Term]\label{def:FO-Term}
  \lean{FirstOrder.Language.Term}\leanok
  \uses{def:FO-Language}
    Let $\mathcal{L} = \langle F, R \rangle$ be a first-order language and $\alpha$ a set used to index free variables. Then the set of terms with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{T}(\mathcal{L},\alpha)$ is the smallest set such that
        \begin{enumerate}
            \item $\alpha \subseteq \mathcal{T}(\mathcal{L},\alpha)$ and
            \item for all $i \in \mathbb{N}$, if $f \in F(i)$ and $x_1,...,x_i \in \mathcal{T}(\mathcal{L},\alpha)$, then $f(x_1,...,x_i) \in \mathcal{T}(\mathcal{L},\alpha)$.
        \end{enumerate}
\end{definition}

The concept of \texttt{Term} is used to define the concept \texttt{BoundedFormula}.

\begin{definition}[First-order BoundedFormula]\label{def:FO-BoundedFormula}
  \lean{FirstOrder.Language.BoundedFormula}\leanok
  \uses{def:FO-Language, def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language, $\alpha$ a set indexing free variables, $n$ the intended number of variables bound by a quantifier and $\mathcal{T}(\mathcal{L}, \alpha \cup \{1,...,n\})$ a set of terms. Then, the set of bounded formulas with respect to these variables $\mathcal{B}(\mathcal{L},\alpha,n)$ is the smallest set such that
    \begin{enumerate}
        \item $\bot \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $t_1,t_2 \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $t_1 = t_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item for all $i \in \mathbb{N}$, if $P \in R_i$ and $t_1,...,t_i \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $P(t_1,...,t_i) \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $f_1,f_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$, then $(f_1 \rightarrow f_2) \in \mathcal{B}(\mathcal{L},\alpha,n)$ and
        \item if $f \in \mathcal{B}(\mathcal{L},\alpha,n+1)$, then $\forall f \in \mathcal{B}(\mathcal{L},\alpha,n)$.
    \end{enumerate}
\end{definition}

Notice that these definitions differ in various ways from classial De Bruijn notation \cite{bruijn:1972}. Firstly, the disjoint union operator in Definition \ref{def:FO-BoundedFormula}'s clauses 2 and 3 guarantees that free variables and variables bound by a quantifier can only be constructed from different sets, whereas in classical De Bruijn all variables are indexed by $\mathbb{Z}$. The reason for such an implementation is that now we can distinguish free variables from bound variable. In that way we enable adding exactly as many distinct variables in sub-formulas of sentences as the amount of quantifiers removed in Definition \ref{def:FO-BoundedFormula}'s recursive step v. Furthermore, free variables can now come from any set, rather than $\mathbb{Z}$, as they are not bound and hence do not have to indicate at what level they are bound. These two notational nuances require a slight rewrite of our example formula \ref{fml:db} to $\forall (\forall(P((0,1)) \rightarrow R(f((1,1)))) \to (R((x_0,0)) \to P(a)))$, where $x_0$ is some element from the relevant type $\alpha$ for indexing free variables.

Formulas and sentences can then conveniently be defined as a \texttt{BoundedFormula} with all its bound variables bound and a \texttt{BoundedFormula} that is a formula and does not contain free variables respectively.

\begin{definition}[First-order Formula]\label{def:FO-Formula}
  \lean{FirstOrder.Language.Formula}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L}$ be a first-order language and $\alpha$ a set indexing variables. Then the set of formulas with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{F}(\mathcal{L},\alpha)$ is defined as the set of bounded formulas $\mathcal{B}(\mathcal{L},\alpha,0)$.
\end{definition}

A \texttt{Sentence} is then defined as a \texttt{Formula} that has no free variables.

\begin{definition}[First-order Sentence]\label{def:FO-Sentence}
  \lean{FirstOrder.Language.Sentence}\leanok
  \uses{def:FO-Language, def:FO-Formula}
    Let $\mathcal{L}$ be a first-order language. Then the set of sentences with respect to $\mathcal{L}$ denoted $\mathcal{S}(\mathcal{L})$ is defined as the set of formulas $\mathcal{F}(\mathcal{L},\emptyset)$.
\end{definition}

\section{Coding}\label{subsec:coding}
All well-formed formulas of some first-order language are encodable as a natural number, a conventional example of this being Gödel encoding, but as \texttt{mathlib} does not yet feature Gödel encoding we use other native functions that have the same properties. Both \texttt{mathlib}'s namespace \texttt{Term} and \texttt{BoundedFormula} have a functions \texttt{listEncode} that encode \texttt{Term}s and \texttt{BoundedFormula}s as \texttt{List}s respectively. These lists can then be encoded as natural numbers using \texttt{mathlib}'s \texttt{Encodable.encodeList}. To encode some language $\mathcal{L}$ into a natural number these functions require encodings for $\mathcal{L}$'s function and relation symbols. Furthermore, they also require a set for indexing variables that is proved to be encodable and since \texttt{mathlib} natively has a proof of the encodability of natural numbers, we use from here on out $\mathbb{N}$ to index our free variables. Hence we obtain our definitions of \texttt{term\_tonat} and \texttt{formula\_tonat}.

\begin{definition}[Encoding terms from formulas with free variables]\label{def:FV-Term-Enc}
  \lean{Languages.TermEncoding.term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},\mathbb{N} \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[Encoding terms from sentences]\label{def:S-Term-Enc}
  \lean{Languages.TermEncoding.sentence_term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},Empty \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[BoundedFormula with Free Variables to $\mathbb{N}$ Encoding]\label{def:FV-Formula-to-N}
  \lean{Languages.TermEncoding.formula_tonat}\leanok
  \uses{def:FO-Language,def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},\mathbb{N},n) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{formula\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}

\begin{definition}[Sentence to $\mathbb{N}$ Encoding]\label{def:S-To-N}
  \lean{Languages.TermEncoding.sent_tonat}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},Empty,0) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{sent\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}


--------------------------------------------ff tot hier----------------------------------------


\section{$\mathcal{L}$ and $\mathcal{L}_T$}\label{subsec:lpa-lt}
Halbach defines the language $\mathcal{L}$ as the language of \texttt{PA}. As ``Peano arithmetic contains the defining equations for zero, successor, addition, and multiplication'' \cite[p. 30]{halbach:2011}, $\mathcal{L}$ hence needs at least functions symbols for zero (0-ary), successor (1-ary), addition (2-ary), and multiplication (2-ary). He then states ``[a]dding a new unary predicate symbol $T$ to the language $\mathcal{L}$ of arithmetic yields the language $\mathcal{L}_T$,'' \cite[p. 31]{halbach:2011}.

Furthermore, it is the case that ``[t]he expressions of the language $\mathcal{L}_T$ can be encoded in the natural numbers,'' and ``[t]he numeral of a number $n$ (...) is the symbol 0 preceded by $n$ occurrences of the successor symbol'' \cite[p. 31]{halbach:2011}, making numerals expressible in $\mathcal{L}$. Hence, the expressions of the language $\mathcal{L}_T$ can be encoded in $\mathcal{L}$. Following Halbach we denote the numeral of the code of some expression $\varphi$ of $\mathcal{L}_T$ by $\ulcorner \varphi \urcorner$. For example, if $t$ is some term of $\mathcal{L}_T$, for which \texttt{term\_tonat}($t) = 3$, then $\ulcorner t \urcorner = SSS0$.

Even more conveniently, ``[i]n Peano arithmetic, all recursive functions can be represented'' and ``[c]ertain syntactic operations on expressions of $\mathcal{L}_T$ are primitive recursive,'' \cite[p. 31--32]{halbach:2011}. These syntactic operations include negation ($\neg$), conjunction ($\wedge$), disjunction ($\vee$), implication ($\supset$), universal quantification ($\forall$), existential quantification ($\exists$) and substitution of a term $t$ for a term $x$ in a formula $\varphi$ ($\varphi(t/x)$). For all these functions it is useful to have a corresponding function symbol in $\mathcal{L}$, to make it easy to identify the $\mathcal{L}_T$ operation they correspond with. For example, if we add the symbol \d{$\neg$} to $\mathcal{L}$ the statement \d{$\neg$} $\ulcorner \varphi \urcorner = \ulcorner \neg \varphi \urcorner$, where $\varphi$ is an expression in $\mathcal{L}_T$, becomes expressible in $\mathcal{L}$.

Note, however, that \d{$\neg$} is not applicable to all $\mathcal{L}_T$-expressions. In particular it should only be applicable to the numeral-encodings of $\mathcal{L}_T$ formulas. Hence, what we would want to express in $\mathcal{L}$ about \d{$\neg$} is $Form(\ulcorner \varphi \urcorner) \supset$ \d{$\neg$}$\ulcorner \varphi \urcorner = \ulcorner \neg \varphi \urcorner$, where $Form$ is the predicate containing the codes of all $\mathcal{L}_T$-expressions that are formulas. Luckily, ``[a]ll recursive sets can be strongly represented in \texttt{PA}, and all recursively enumerable sets can be weakly represented in \texttt{PA}'' \cite[p. 31]{halbach:2011}, meaning we can express the meaning of the predicate $Form$ in $\mathcal{L}$.

For analogous reasons, it is useful to add relation-symbols $Var$, $Const$, $Term$, $ClTerm$, $Sentencel$, $Forml$, $Formlt$ and $Sentencelt$ to $\mathcal{L}$, denoting the predicates containing the codes of all $\mathcal{L}_T$-variables, terms, closed term, sentences without the $T$ predicate, formulas
without the $T$ predicate, formulas with the $T$ predicate, and sentences with the $T$ predicate, respectively.

Hence, we have identified all the necessary function and relations symbols for our language $\mathcal{L}$, and by adding the $T$ predicate to that also those of $\mathcal{L}_T$. 

\begin{definition}[$\mathcal{L}$: the language of peano arithmetic with syntactic functions and predicates]\label{def:l}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$, where
    \begin{itemize}
        \item $F_0 = \{0\}$,
        \item $F_1 = \{S,$ \d{$\neg$} , \d{$\forall$}, \d{$\exists$}, ${^\circ}\}$,
        \item $F_2 = \{+,\times,$ \d{$\wedge$}, \d{$\vee$}, \d{$\supset$}$\}$ and
        \item $F_3 = \{$ \d{$subs$}$\}$ and
        \item $R_1 = \{Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, \\ Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.$
    \end{itemize}
\end{definition} 

\begin{definition}[$\mathcal{L}_{T}$: the language of Peano arithmetic including the truth predicate symbol]\label{def:lt}
    Let $\mathcal{L} = \langle F, (R_i)_{i \in \mathbb{N}} \rangle$ be the language of Peano arithmetic including syntactic functions symbols and predicates. Then, the language $\mathcal{L}_T$ is the first-order language $\mathcal{L}_T = \langle F, (R_{T,i})_{i \in \mathbb{N}} \rangle$, where $R_{T,1} = R_1 \cup \{T\}$.
\end{definition}

As noted in Section \ref{subsec:coding} for the encoding functions to work an explicit encoding of $\mathcal{L}$ and $\mathcal{L}_T$'s function and relation symbols has to be given. However, as Halbach leaves the specific encodings implicit, we will for here do to.

\section{Axiomatization}\label{subsec:axiomatization}
Once we have a formal language and specification of its formulas, we can define the theories we want to reason about. In \texttt{mathlib} theories are indexed by their defining axioms, so constructing a theory is equivalent to specifying its defining axioms. 

\begin{definition}[theory]\label{def:theory}
  Let $\mathcal{L}$ be a formal language and $W_{\mathcal{L}}$ its associated set of sentences. Then, a theory $T_{\mathcal{L}}$ of $\mathcal{L}$ is a set of sentences $X$ such that $X \subset W_{\mathcal{L}}$.
\end{definition}

We can hence use the notions of $\mathcal{L}$ and $\mathcal{L}_T$ to construct the theories of \texttt{PA}, \texttt{PAT} and \texttt{TB}, which are all formulated in either of those languages. ``The system of Peano arithmetic contains the defining equations for zero, successor, addition, and multiplication'' \cite[p. 30]{halbach:2011}, which can be axiomatized in the following way: 
\begin{definition}[\texttt{PA}: the theory of Peano arithmetic]
    The theory of Peano arithmetic \texttt{PA} is defined as the smallest set $X$ such that
    \begin{enumerate}
        \item $\forall x (0 \not = S(x)) \in X$, 
        \item $\forall x,y (S(x) = S(y) \rightarrow x = y) \in X$,
        \item $\forall x(x + 0 = x) \in X$,
        \item $\forall x,y(x + S(y) = S(x+y)) \in X$,
        \item $\forall x(x \cdot 0 = 0) \in X$,
        \item $\forall x,y(x \cdot S(y) = x \cdot y + x) \in X$ and
        \item if $\varphi(x,y_1,...,y_k) \in \mathcal{L}$, then $\bar y \Bigl( \bigl(\varphi(0,\bar y) \land \forall x (\varphi(x,\bar y) \to \varphi(S(x),\bar y))\bigr)\Bigr) \to \forall x \varphi(x, \bar y)$, where $\bar y = y_1,...,y_k$
    \end{enumerate}
\end{definition}

\begin{definition}[\texttt{PAT}]
    We define the system \texttt{PAT} as the system of Peano arithmetic formulated in $\mathcal{L}_T$ including the induction schema for each formula of the language $\mathcal{L}_T$.
\end{definition}

\begin{definition}[\texttt{TB}]
    The system \texttt{TB} comprises all axioms of \texttt{PAT}. Moreover all sentences of the form $T\ulcorner\varphi\urcorner \leftrightarrow \varphi$ are axioms of the system where $\varphi$ is a sentence of the language of $\mathcal{L}$ and $\ulcorner \varphi \urcorner$ is the numeral of $\varphi$'s Gödel code.
\end{definition}

\section{Proof Theory}\label{subsec:proof-theory}
As a theory is ``a set of formulae closed under first-order logical consequence'' \cite[p. 29]{halbach:2011}, we have to have a notion of how first-order formulae are derived from the axioms of theories. This is made precise by the notion of a formal systems: ``a collection of axioms and rules for generating theorems'' \cite[p. 29]{halbach:2011}.

Proof systems hence require three elements:
\begin{enumerate}
\item a formal language,
\item a set of formulas in the language that function as axioms and
\item a set of rules for deriving formulas from other formulas, that are sound and complete with respect to first-order logical consequence.
\end{enumerate}

As we have defined the languages $\mathcal{L}$ and $\mathcal{L}_T$ in Section \ref{subsec:lpa-lt} and the axioms of \texttt{PA}, \texttt{PAT}, \texttt{TB} in Section \ref{subsec:axiomatization}, we only still need the notion of item 3.

\begin{definition}[first free variable substitution in terms]
  still to be defined
    %% Let $\mathcal{S} = (\mathcal{C},\mathcal{F},\mathcal{R},ar)$ be a first order signature. Then, we define the substitution function over terms $subt_{\mathcal{S}} : \mathcal{T}_{\mathcal{S}} \times \mathcal{V} \times \mathcal{T}_{\mathcal{S}} \to \mathcal{T}_{\mathcal{S}}$ recursively such that
    %% \begin{enumerate}
    %%     \item if $s \in \mathcal{P}_{\mathcal{S}}$, then $subt_{\mathcal{S}}(s,x,t) = \begin{cases}
    %%                     s, &\text{if }s \not = x \\
    %%                     t, &\text{if }s = x
    %%                     \end{cases}$
    %%     \item $subt_{\mathcal{S}}(f(t_1,...,t_n),x,t) = f(subt_{\mathcal{S}}(t_1,x,t),...,subt_{\mathcal{S}}(t_n,x,t))$.
    %% \end{enumerate}
\end{definition}

\begin{definition}[substitution first free variable]\label{def:subst}
  still to be defined
%%     Let $\mathcal{F} = B_{\mathcal{L},\mathbb{N},n}$ be a set of semiformulae and $\mathcal{T} = A_{\mathcal{L},\mathbb{N},n}$ a set of terms. Then, the substitution function $\texttt{sub}_f : \mathcal{F} \times \mathcal{T}^{n} \to \mathcal{F}$, of terms $\textbf{t} \in \mathcal{T}$, where $\textbf{t} = (t_1,...,t_n)$, in formula $\varphi \in \mathcal{F}$, denoted $\varphi/[\textbf{t}]$, is inductively defined as
%%     \begin{enumerate}
%%         \item $\texttt{verum}/[\textbf{t}] = \texttt{verum}$;
%%         \item $\texttt{falsum}/[\textbf{t}] = \texttt{falsum}$;
%%         \item if $P(a_1,...,a_k) \in \mathcal{F}$, then $P(a_1,...,a_k)/[\textbf{t}] = P(\texttt{sub}_t(a_1,\textbf{t}),...,\texttt{sub}(a_k,\textbf{t}))$;
%%         \item if $\neg P(a_1,...,a_k) \in \mathcal{F}$, then $ \neg P(a_1,...,a_k)/[\textbf{t}] = \neg P(\texttt{sub}_t(a_1,\textbf{t}),...,\texttt{sub}_t(a_k,\textbf{t}))$;
%%         \item if $\texttt{and}(\varphi_1, \varphi_2) \in \mathcal{F}$, then $\texttt{and}(\varphi_1, \varphi_2)/[\textbf{t}] = \texttt{and}(\varphi_1/[\textbf{t}],\varphi/[t])$;
%%         \item if $\texttt{or}(\varphi_1, \varphi_2) \in \mathcal{F}$, then $\texttt{or}(\varphi_1, \varphi_2)/[\textbf{t}] = \texttt{or}(\varphi_1/[\textbf{t}],\varphi/[\textbf{t}])$;
%%         \item if $\texttt{all}(\varphi) \in \mathcal{F}$, then $\texttt{all}(\varphi)/[\textbf{t}] = \texttt{all}(\varphi/[\textbf{t}])$ and
%%         \item if $\texttt{ex}(\varphi)\in \mathcal{F}$, then $\texttt{ex}(\varphi)/[\textbf{t}] = \texttt{ex}(\varphi/[\textbf{t}])$.
%%     \end{enumerate}
\end{definition}

Halbach mentions that in situations where it is necessary to specify the exact logical rules in derivations he will use a sequent calculus \cite[p. 29]{halbach:2011}. Since we need a fully syntactical notion of closure under first-order inference, we need to implement a concrete calculus to have an idea of what first-order closure is. We hence implement a notion of sequent calculus derivations of formulae.

\begin{definition}[sequent calculus inference rules]
    Let $\mathcal{L}$ be a formal language, and $Th$ some set of $Th \subseteq \mathcal{S}(\mathcal{L})$ functioning as axioms. Then the inference rules of sequent calculus are
    \begin{enumerate}
        \item $r_{lax} : \mathcal{P}(\mathcal{F}(\mathcal{L}, \mathbb{N}))^2 \to \mathcal{P}(\mathcal{F}(\mathcal{L},\mathbb{N}))^2$ defined by $r_{lax}(\Gamma,\Delta) = (\Gamma \cup \{\varphi\}, \Delta \cup \{\varphi\})$, where $\varphi \in \mathcal{F}(\mathcal{L},\mathbb{N})$,
        \item $r_{tax} : \mathcal{P}(\mathcal{F}(\mathcal{L}, \mathbb{N}))^2 \to \mathcal{P}(\mathcal{F}(\mathcal{L}, \mathbb{N}))^2$ defined by $r_{tax}(\Gamma, \Delta) = (\Gamma, \Delta \cup \{\phi\})$, where $\varphi \in Th$,
        \item PROCEED HERE          
        %% \item $r_{cut} : \mathcal{S}^2 \to \mathcal{S}$ defined by $r_{cut}((\Gamma,\Delta \cup \{\phi\}),(\{\phi\} \cup \Sigma,\Pi))=(\Gamma \cup \Sigma, \Delta \cup \Pi)$,
        %% \item $r_{\land L_1} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\land L_1}((\Gamma \cup \{\phi\}, \Delta))=(\Gamma \cup \{\phi \land \psi\}, \Delta)$,
        %% \item $r_{\land L_2} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\land L_2}((\Gamma \cup \{\psi\}, \Delta))=(\Gamma \cup \{\phi \land \psi\}, \Delta)$,
        %% \item $r_{\lor L} : \mathcal{S}^2 \to \mathcal{S}$ defined by $r_{\lor L}((\Gamma \cup \{\phi\},\Delta),(\Gamma \cup \{\psi\},\Delta))=(\Gamma \cup \{\phi \lor \psi\},\Delta)$,
        %% \item $r_{\to L} : \mathcal{S}^2 \to \mathcal{S}$ defined by $r_{\to L}((\Gamma, \{\phi\} \cup \Delta),(\Sigma \cup \{\psi\},\Pi))=(\Gamma \cup \Sigma \cup \{(\phi \to \psi)\},\Delta \cup \Pi)$,
        %% \item $r_{\neg L} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\neg L}(\Gamma,\{\phi\} \cup \Delta)=(\Gamma \cup \{\neg \phi\},\Delta)$,
        %% \item $r_{\forall L} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\forall L}(\Gamma \cup \{\phi [t/x]\},\Delta)=(\Gamma \cup \{ \forall x \phi \},\Delta)$,

    \end{enumerate}
\end{definition}

\noindent \textcolor{red}{[I haven't reviewed from here on out.]}

\section{Disquotation}\label{subsec:disquotation}
\begin{definition}[conservativity]
    A truth system $...$ [\textcolor{red}{how do you get this symbol?}] in the language $\mathcal{L}_T$ is conservative over a system $\mathcal{S}$ formulated in language $\mathcal{L}$ without the truth predicate if and only if all sentences $s \in \mathcal{L}$ provable by $...$ are also provable by $\mathcal{S}$.
\end{definition}

\begin{lemma}[finite axioms in TB]
    In a proof in \texttt{TB} only finitely many axioms can occur.
\end{lemma}

\begin{proof}
    Let $p$ be a proof in \texttt{TB}. Then, by Definition \verb|\ref{def:formal-proof}|, $p$ is a finite sequence of sentences each of which is an axiom of \texttt{TB} or follows from the preceding sentences according to first-order rules of inference. The amount of axioms the proof contains is less or equal to the total number of sentences. Hence, the number of axioms in the proof should also be finite. 
\end{proof}

\begin{theorem}
    \texttt{TB} is conservative over \texttt{PA}.
\end{theorem}

\begin{proof}
Let $\psi$ be a formula in $\mathcal{L}$ that is provable in TB by a proof $p$. Then, by Lemma \verb|\ref{lem:finit-ax-tb}|, we have that $p$ contains finitely many sentences as axioms. Let $n$ be the number of disquotation sentences occurring as axioms in the proof. Then, every axiom $p$ is either (i) an axiom of \texttt{PA}, or (ii) an instance of the induction schema, or (iii) for some $i \leq n$, a sentence of the form: 
\begin{align*}
    T\ulcorner \varphi_i \urcorner \leftrightarrow \varphi_i.
\end{align*}
As axioms of type (i) and (ii) are sentences of $\mathcal{L}$, we need only show how to transform any given disquotation axiom into a logically equivalent sentence of $\mathcal{L}$. Now, let $\tau(x)$ be the formula: 
\begin{align*}
    (x = \ulcorner \varphi_1 \urcorner \land \varphi_1) \lor ... \lor (x = \ulcorner \varphi_k \urcorner \land \varphi_k).
\end{align*}
By Lemma \verb|\ref{lem:Tphi-eq-tau}|, we have that $T\ulcorner \varphi \urcorner \iff \tau(\ulcorner \varphi \urcorner)$. Hence, we can replace all occurrences of the truth predicate $T$ in the given \texttt{TB}-proof with $\tau$. Then the disquotation ...
\end{proof}

We will here define proof systems for $\texttt{PA}$, $\texttt{PAT}$ and $\texttt{TB}$. As all these theories have to be closed under first-order inference, the rules for deriving formulas from other formulas can be the same for each theory. We hence need to formulate the axioms of these theories and a general notion of first-order provability. 

\begin{definition}[formal proof]
    A formal proof in a logical system $\mathcal{S}$ is a finite sequence of sentences, where each sentence is an axiom of $\mathcal{S}$, an assumption, or follows from the application of one of $\mathcal{S}$'s rules of inference to previous sentences in the sequence (Wikipedia: Formal proof).
\end{definition}

\begin{definition}[provability]
    A formula $\varphi$ is provable in a proof system $\mathcal{S}$ if and only if there exists a formal proof $\mathcal{P}$ in $\mathcal{S}$, such that $\mathcal{P}$ contains no assumptions and $\varphi$ is the last sentence of $\mathcal{P}$.
\end{definition}


