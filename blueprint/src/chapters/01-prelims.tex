\chapter{Preliminaries}
Section \ref{subsec:notation} will first provide some notes on notation. Then, Section \ref{subsec:language} will focus on the concepts of a first-order language and formulas, Section \ref{subsec:coding} will focus on how formulas can be encoded in natural numbers, Section \ref{subsec:lpa-lt} will discuss the specific languages of $\mathcal{L}$ and $\mathcal{L}_T$, Section \ref{subsec:axiomatization} discusses the axioms of \texttt{PA}, \texttt{PAT} and \texttt{TB}, Section \ref{subsec:proof-theory} will provide the necessary concepts for reasoning about derivations and finally Section \ref{subsec:disquotation} will discuss the concepts and final proof of the conservativity of \texttt{TB} over \texttt{PA}.

\section{Notation}\label{subsec:notation}
We aim to make this exposition intuitive for those not specialized in type theory. Hence, we will present the formal specification of the concepts in such a way that they are on the one hand as suggestive for their Lean implementation as possible while at the same time being stated in set theoretic terms rather than type theoretic ones. This made possible by an intuitive correspondence between types and sets (see e.g. \cite{nederpelt:1994}).

Moreover, as Lean has additional functionalities on top of its type theoretic basis to allow for efficient programming and proof verification, some limitations arise preventing the code from following exactly the common conceptualizations of set theoretic mathematics. The most notable of these deviations is that the symbol \texttt{0} in Lean has a reserved meaning, namely \texttt{Nat.zero}, an inhabitant of the primitive type \texttt{Nat}, describing the natural numbers. As we shall also define a language involving the concept of zero, we will hence name it \texttt{null}.

To allow for efficient automatic formulas manipulation, variables bound by a quantifier are associated with De Bruijn \cite{bruijn:1972} indices in \texttt{mathlib}'s implementation of first-order formulas. These indices are natural numbers that correspond to the level-distance between the variable and the quantifier that binds it. Take as an example the regular first-order formula 
\begin{align}
    \forall x (\forall y (P(y) \to R(f(x))) \to (R(z) \to P(a))),
\end{align} where $x, y$ are bound variables, $z$ is a free variables, $P$ and $R$ are predicates and $a$ is a constant.
In De Bruijn notation this formula is expressed by
\begin{align}\label{fml:db}
    \forall (\forall (P(0) \to R(f(1))) \to (R(1) \to P(a))).
\end{align}
Troughout this chapter we will use this formula as illustration to the concepts introduced.

\section{Language}\label{subsec:language}
The ordinary definition of a first-order language $\mathcal{L}$ proceeds from the specification of a signature $\mathcal{S}$ and then an inductive definition of the way formulas can be build with elements from $\mathcal{S}$, the set of logical connectives, variables and the quantifiers. See that for any first order language all these elements except the signature are the same. Hence, we could think of a specific first order language as being fully specified by its signature.

\begin{definition}[First-order Language]\label{def:FO-Language}
\lean{FirstOrder.Language}\leanok
  A language is a structure $\langle(F_i)_{i\in \mathbb{N}}, (R_i)_{i\in \mathbb{N}})\rangle$, where $F_i$ is a set of $i$-ary function symbols and $R_i$ a set of $i$-ary predicate symbols.
\end{definition}

Note that this defines a language as consisting only of functions and relations, whereas in philosophical logic it is more conventional that a language also contains a set of constants, like in Negri \& Von Plato \cite{negri:2001}. Observe, however, that constants can be modeled as $0$-ary functions, so this definition of a language does not limit expressive power. By providing concrete sets of function and relation symbols to $F_i$ and $R_i$ we obtain a specific language. So, the language in which our formula \ref{fml:db} is stated can be defined as $\mathcal{L}_{ex} = \langle (F_{ex,i})_{i \in \mathbb{N}}, (R_{ex,i})_{i \in \mathbb{N}} \rangle$, where $(F_{ex,i})_{i \in \mathbb{N}}$ is defined by $F_{ex,0} = \{a\}$ and $F_{ex,1} = \{f\}$ and $(R_{ex,i})_{i \in \mathbb{N}}$ is defined by $R_{ex,1} = \{P, R\}$.

Now, we can use these specifications in \texttt{mathlib}'s implementation of \texttt{Term}s and \texttt{BoundedFormula}s.

\begin{definition}[First-order Term]\label{def:FO-Term}
  \lean{FirstOrder.Language.Term}\leanok
  \uses{def:FO-Language}
    Let $\mathcal{L} = \langle F, R \rangle$ be a first-order language and $\alpha$ a set used to index free variables. Then the set of terms with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{T}(\mathcal{L},\alpha)$ is the smallest set such that
        \begin{enumerate}
            \item $\alpha \subseteq \mathcal{T}(\mathcal{L},\alpha)$ and
            \item for all $i \in \mathbb{N}$, if $f \in F(i)$ and $x_1,...,x_i \in \mathcal{T}(\mathcal{L},\alpha)$, then $f(x_1,...,x_i) \in \mathcal{T}(\mathcal{L},\alpha)$.
        \end{enumerate}
\end{definition}

The concept of \texttt{Term} is used to define the concept \texttt{BoundedFormula}.

\begin{definition}[First-order BoundedFormula]\label{def:FO-BoundedFormula}
  \lean{FirstOrder.Language.BoundedFormula}\leanok
  \uses{def:FO-Language, def:FO-Term, def:Disjoint-Union}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language, $\alpha$ a set indexing free variables, $n$ the intended number of variables bound by a quantifier and $\mathcal{T}(\mathcal{L}, \alpha \cup \{1,...,n\})$ a set of terms. Then, the set of bounded formulas with respect to these variables $\mathcal{B}(\mathcal{L},\alpha,n)$ is the smallest set such that
    \begin{enumerate}
        \item $\bot \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $t_1,t_2 \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $t_1 = t_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item for all $i \in \mathbb{N}$, if $P \in R_i$ and $t_1,...,t_i \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $P(t_1,...,t_i) \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $f_1,f_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$, then $(f_1 \rightarrow f_2) \in \mathcal{B}(\mathcal{L},\alpha,n)$ and
        \item if $f \in \mathcal{B}(\mathcal{L},\alpha,n+1)$, then $\forall f \in \mathcal{B}(\mathcal{L},\alpha,n)$.
    \end{enumerate}
\end{definition}

Notice that these definitions differ in various ways from classial De Bruijn notation \cite{bruijn:1972}. Firstly, the disjoint union operator in Definition \ref{def:FO-BoundedFormula}'s clauses 2 and 3 guarantees that free variables and variables bound by a quantifier can only be constructed from different sets, whereas in classical De Bruijn all variables are indexed by $\mathbb{Z}$. The reason for such an implementation is that now we can distinguish free variables from bound variable. In that way we enable adding exactly as many distinct variables in sub-formulas of sentences as the amount of quantifiers removed in Definition \ref{def:FO-BoundedFormula}'s recursive step v. Furthermore, free variables can now come from any set, rather than $\mathbb{Z}$, as they are not bound and hence do not have to indicate at what level they are bound. These two notational nuances require a slight rewrite of our example formula \ref{fml:db} to $\forall (\forall(P((0,1)) \rightarrow R(f((1,1)))) \to (R((x_0,0)) \to P(a)))$, where $x_0$ is some element from the relevant type $\alpha$ for indexing free variables.

Formulas and sentences can then conveniently be defined as a \texttt{BoundedFormula} with all its bound variables bound and a \texttt{BoundedFormula} that is a formula and does not contain free variables respectively.

\begin{definition}[First-order Formula]\label{def:FO-Formula}
  \lean{FirstOrder.Language.Formula}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L}$ be a first-order language and $\alpha$ a set indexing variables. Then the set of formulas with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{F}(\mathcal{L},\alpha)$ is defined as the set of bounded formulas $\mathcal{B}(\mathcal{L},\alpha,0)$.
\end{definition}

A \texttt{Sentence} is then defined as a \texttt{Formula} that has no free variables.

\begin{definition}[First-order Sentence]\label{def:FO-Sentence}
  \lean{FirstOrder.Language.Sentence}\leanok
  \uses{def:FO-Language, def:FO-Formula}
    Let $\mathcal{L}$ be a first-order language. Then the set of sentences with respect to $\mathcal{L}$ denoted $\mathcal{S}(\mathcal{L})$ is defined as the set of formulas $\mathcal{F}(\mathcal{L},\emptyset)$.
\end{definition}

\section{Coding}\label{subsec:coding}
All well-formed formulas of some first-order language are encodable as a natural number, a conventional example of this being Gödel encoding, but as \texttt{mathlib} does not yet feature Gödel encoding we use other native functions that have the same properties. Both \texttt{mathlib}'s namespace \texttt{Term} and \texttt{BoundedFormula} have a functions \texttt{listEncode} that encode \texttt{Term}s and \texttt{BoundedFormula}s as \texttt{List}s respectively. These lists can then be encoded as natural numbers using \texttt{mathlib}'s \texttt{Encodable.encodeList}. To encode some language $\mathcal{L}$ into a natural number these functions require encodings for $\mathcal{L}$'s function and relation symbols. Furthermore, they also require a set for indexing variables that is proved to be encodable and since \texttt{mathlib} natively has a proof of the encodability of natural numbers, we use from here on out $\mathbb{N}$ to index our free variables. Hence we obtain our definitions of \texttt{term\_tonat} and \texttt{formula\_tonat}.

\begin{definition}[Encoding terms from formulas with free variables]\label{def:FV-Term-Enc}
  \lean{Languages.TermEncoding.term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},\mathbb{N} \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[Encoding terms from sentences]\label{def:S-Term-Enc}
  \lean{Languages.TermEncoding.sentence_term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},Empty \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[BoundedFormula with Free Variables to $\mathbb{N}$ Encoding]\label{def:FV-Formula-to-N}
  \lean{Languages.TermEncoding.formula_tonat}\leanok
  \uses{def:FO-Language,def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},\mathbb{N},n) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{formula\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}

\begin{definition}[Sentence to $\mathbb{N}$ Encoding]\label{def:S-To-N}
  \lean{Languages.TermEncoding.sent_tonat}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},Empty,0) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{sent\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}


\section{$\mathcal{L}$ and $\mathcal{L}_T$}\label{subsec:lpa-lt}
We define the language of Peano Arithmetic based on our notion of a language. We hence first need to define a family of function and relation symbols, indexed by their arity. We also include function symbols that stand for some recursively definable logical operators.

\begin{definition}[The Family of Function Symbols for the Language of Peano Arithmetic]\label{def:L-Func}
  \lean{Languages.LPA.Func}\leanok
  We define $(F_{\mathcal{L},i})_{i \in \mathbb{N}}$ by
  \begin{enumerate}
  \item $(F_{\mathcal{L},0}) = \{\texttt{null}\}$,
  \item $(F_{\mathcal{L},1}) = \{S, \underdot{\neg} , \underdot{\forall}, \underdot{\exists}, {^\circ}\}$,
  \item $(F_{\mathcal{L},2}) = \{+,\times, \underdot{\wedge}, \underdot{\vee}, \underdot{\supset}\}$ and
  \item $(F_{\mathcal{L},3}) = \{\underdot{subs}\}$.
  \end{enumerate}
\end{definition}

\begin{definition}[The Family of Relation Symbols for the Language of Peano Arithmetic]\label{def:L-Rel}
  \lean{Languages.LPA.Rel}\leanok
  We define $(R_{\mathcal{L},i})_{i \in \mathbb{N}}$ by \[R_1 = \{Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, \\ Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.\]
\end{definition}

\begin{definition}[$\mathcal{L}$: the Language of Peano Arithmetic with Syntactic Function and Relation Symbols]\label{def:L}
  \lean{Languages.LPA.signature}\leanok
  \uses{def:FO-Language,def:L-Func,def:L-Rel}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L} = \langle (F_{\mathcal{L},i})_{i \in \mathbb{N}}, (R_{\mathcal{L},i})_{i \in \mathbb{N}} \rangle$.
\end{definition}

We define the language of $\mathcal{L}_T$ as the language $\mathcal{L}$ one relation symbol added: $Tr$. Hence its Function symbols are equivalent to that of $\mathcal{L}$ and the relation symbols only feature an extra $Tr$.

\begin{definition}[The Family of Function Symbols for the Language of Peano Arithmetic]\label{def:L_T-Func}
  \lean{Languages.L_T.Func}\leanok
  We define $(F_{\mathcal{L}_T,i})_{i \in \mathbb{N}}$ by
  \begin{enumerate}
  \item $(F_{\mathcal{L},0}) = \{\texttt{null}\}$,
  \item $(F_{\mathcal{L},1}) = \{S, \underdot{\neg} , \underdot{\forall}, \underdot{\exists}, {^\circ}\}$,
  \item $(F_{\mathcal{L},2}) = \{+,\times, \underdot{\wedge}, \underdot{\vee}, \underdot{\supset}\}$ and
  \item $(F_{\mathcal{L},3}) = \{\underdot{subs}\}$.
  \end{enumerate}
\end{definition}

\begin{definition}[The Family of Relation Symbols for the Language of Peano Arithmetic]\label{def:L_T-Rel}
  \lean{Languages.L_T.Rel}\leanok
  We define $(R_{\mathcal{L}_T,i})_{i \in \mathbb{N}}$ by \[R_1 = \{Tr,Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.\]
\end{definition}

\begin{definition}[$\mathcal{L}_T$: the Language of Peano Arithmetic with Syntactic Function and Relation Symbols]\label{def:L_T}
  \lean{Languages.L_T.signature}\leanok
  \uses{def:FO-Language,def:L_T-Func,def:L_T-Rel}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L}_T = \langle (F_{\mathcal{L}_T,i})_{i \in \mathbb{N}}, (R_{\mathcal{L}_T,i})_{i \in \mathbb{N}} \rangle$.
\end{definition}

As noted in Section \ref{subsec:coding} for the encoding functions to work an explicit encoding of $\mathcal{L}$ and $\mathcal{L}_T$'s function and relation symbols has to be given. However, as Halbach leaves the specific encodings implicit, we will for here do to.

\section{Axiomatization}\label{subsec:axiomatization}
Once we have a formal language and specification of its formulas, we can define the theories we want to reason about. In \texttt{mathlib} theories are defined by their axioms, so constructing a theory is equivalent to specifying its axioms. 

\begin{definition}[Theory]\label{def:FO-Theory}
  \lean{FirstOrder.Language.Theory}\leanok
  \uses{def:FO-Language,def:FO-Sentence}
  Let $\mathcal{L}$ be a formal language and $S_{\mathcal{L}}$ its associated set of sentences. Then, a theory of $\mathcal{L}$ is a set of sentences $T_{\mathcal{L}}$ such that $T_{\mathcal{L}} \subseteq S_{\mathcal{L}}$.
\end{definition}

We can hence use the notions of $\mathcal{L}$ and $\mathcal{L}_T$ to construct the theories of Syntax Theory, Peano Arithmetic \texttt{PA}, Peano Arithmetic with T \texttt{PAT} and Peano Arithmetic with T and Tarski Biconditionals \texttt{TB}. For Syntax Theory we provide the primitive recursive logical operations as axioms.
\subsubsection{Syntax Axioms}
\begin{definition}[Syntactic Negation Operator Axiom]\label{def:Syntactic-Neg}
  \lean{SyntaxAxioms.neg_repres}\leanok
  \uses{def:FO-Language,def:L,def:Not,def:L-Numeral}
  The meaning of the syntactic negation operator $\underdot{\neg}$ meaning is captured by the axiom $\forall \phi \in \mathcal{F}(\mathcal{L},\mathbb{N})(\underdot{\neg} \ulcorner \phi \urcorner = \ulcorner \neg \phi \urcorner)$. 
\end{definition}


\begin{definition}[Syntax Theory]\label{def:Syntax-Theory}
  \lean{SyntaxTheory.syntax_theory_l}\leanok
  \uses{def:FO-Theory,def:L}
  We define Syntax Theory as the theory $\{\texttt{neg\_repres},\texttt{conj\_repres},\texttt{disj\_repres},\texttt{cond\_repres},\texttt{forall\_repres},\texttt{exists\_repres},\texttt{subs\_repres},\texttt{term\_repres},\texttt{formulaL\_repres},\texttt{formulaL\_T\_repres},\texttt{sentenceL\_repres},\texttt{sentenceL\_T\_repres},\texttt{closed\_term\_repres},\texttt{var\_repres},\texttt{const\_repres},\texttt{denote\_repres}\}$.
\end{definition}

The system of Peano arithmetic contains the defining equations for zero, successor, addition, and multiplication. We first provide the finite theory of the first 6 Peano axioms.
\begin{definition}[The First 6 Axioms of Peano Arithmetic]\label{def:PA-Axioms}
  \lean{PA.peano_axioms}\leanok
  \uses{def:FO-Language,def:FO-Theory,def:L}
    The theory of the first 6 axioms of Peano Arithmetic \texttt{PA-axioms} is defined as the smallest theory $X$ such that
    \begin{enumerate}
        \item $\forall \neg ((0,1) = S((0,1)) \in X$, 
        \item $\forall \forall (S((1,1)) = S((0,1)) \rightarrow (1,1) = (0,1)) \in X$,
        \item $\forall ((0,1) + \texttt{null} = (0,1)) \in X$,
        \item $\forall \forall ((1,1) + S((0,1)) = S((1,1)+(0,1))) \in X$,
        \item $\forall ((0,1) \cdot \texttt{null} = \texttt{null}) \in X$ and
        \item $\forall  \forall ((1,1) \cdot S((0,1)) = (1,1) \cdot (0,1) + (1,1)) \in X$.
    \end{enumerate}
\end{definition}

Then we define \texttt{PA} as the union of the first 6 Peano axioms and all the instances of the induction scheme for \texttt{PA}.
\begin{definition}[\texttt{PA}: The Theory of Peano Arithmetic]\label{def:PA}
  \lean{PA.peano_arithmetic}\leanok
  \uses{def:PA-Axioms,def:FO-Formula}
  We define \texttt{PA} as the theory $\texttt{PA-axioms} \cup \{φ | ∃ψ \in \mathcal{F}(\mathcal{L},{0}) : φ = ((ψ(0) \wedge ∀x(ψ(x) ⟹ ψ(S(x)))) ⟹ ∀xψ(x))\}$.
\end{definition}

\begin{definition}[\texttt{PAT}]
    We define the system \texttt{PAT} as the system of Peano arithmetic formulated in $\mathcal{L}_T$ including the induction schema for each formula of the language $\mathcal{L}_T$.
\end{definition}

\begin{definition}[\texttt{TB}]
    The system \texttt{TB} comprises all axioms of \texttt{PAT}. Moreover all sentences of the form $T\ulcorner\varphi\urcorner \leftrightarrow \varphi$ are axioms of the system where $\varphi$ is a sentence of the language of $\mathcal{L}$ and $\ulcorner \varphi \urcorner$ is the numeral of $\varphi$'s Gödel code.
\end{definition}

\section{Proof Theory}\label{subsec:proof-theory}
As a theory is ``a set of formulae closed under first-order logical consequence'' \cite[p. 29]{halbach:2011}, we have to have a notion of how first-order formulae are derived from the axioms of theories. This is made precise by the notion of a formal systems: ``a collection of axioms and rules for generating theorems'' \cite[p. 29]{halbach:2011}.

Proof systems hence require three elements:
\begin{enumerate}
\item a formal language,
\item a set of formulas in the language that function as axioms and
\item a set of rules for deriving formulas from other formulas, that are sound and complete with respect to first-order logical consequence.
\end{enumerate}

As we have defined the languages $\mathcal{L}$ and $\mathcal{L}_T$ in Section \ref{subsec:lpa-lt} and the axioms of \texttt{PA}, \texttt{PAT}, \texttt{TB} in Section \ref{subsec:axiomatization}, we only still need the notion of item 3.

\begin{definition}[first free variable substitution in terms]
  still to be defined
    %% Let $\mathcal{S} = (\mathcal{C},\mathcal{F},\mathcal{R},ar)$ be a first order signature. Then, we define the substitution function over terms $subt_{\mathcal{S}} : \mathcal{T}_{\mathcal{S}} \times \mathcal{V} \times \mathcal{T}_{\mathcal{S}} \to \mathcal{T}_{\mathcal{S}}$ recursively such that
    %% \begin{enumerate}
    %%     \item if $s \in \mathcal{P}_{\mathcal{S}}$, then $subt_{\mathcal{S}}(s,x,t) = \begin{cases}
    %%                     s, &\text{if }s \not = x \\
    %%                     t, &\text{if }s = x
    %%                     \end{cases}$
    %%     \item $subt_{\mathcal{S}}(f(t_1,...,t_n),x,t) = f(subt_{\mathcal{S}}(t_1,x,t),...,subt_{\mathcal{S}}(t_n,x,t))$.
    %% \end{enumerate}
\end{definition}

\begin{definition}[substitution first free variable]\label{def:subst}
  still to be defined
%%     Let $\mathcal{F} = B_{\mathcal{L},\mathbb{N},n}$ be a set of semiformulae and $\mathcal{T} = A_{\mathcal{L},\mathbb{N},n}$ a set of terms. Then, the substitution function $\texttt{sub}_f : \mathcal{F} \times \mathcal{T}^{n} \to \mathcal{F}$, of terms $\textbf{t} \in \mathcal{T}$, where $\textbf{t} = (t_1,...,t_n)$, in formula $\varphi \in \mathcal{F}$, denoted $\varphi/[\textbf{t}]$, is inductively defined as
%%     \begin{enumerate}
%%         \item $\texttt{verum}/[\textbf{t}] = \texttt{verum}$;
%%         \item $\texttt{falsum}/[\textbf{t}] = \texttt{falsum}$;
%%         \item if $P(a_1,...,a_k) \in \mathcal{F}$, then $P(a_1,...,a_k)/[\textbf{t}] = P(\texttt{sub}_t(a_1,\textbf{t}),...,\texttt{sub}(a_k,\textbf{t}))$;
%%         \item if $\neg P(a_1,...,a_k) \in \mathcal{F}$, then $ \neg P(a_1,...,a_k)/[\textbf{t}] = \neg P(\texttt{sub}_t(a_1,\textbf{t}),...,\texttt{sub}_t(a_k,\textbf{t}))$;
%%         \item if $\texttt{and}(\varphi_1, \varphi_2) \in \mathcal{F}$, then $\texttt{and}(\varphi_1, \varphi_2)/[\textbf{t}] = \texttt{and}(\varphi_1/[\textbf{t}],\varphi/[t])$;
%%         \item if $\texttt{or}(\varphi_1, \varphi_2) \in \mathcal{F}$, then $\texttt{or}(\varphi_1, \varphi_2)/[\textbf{t}] = \texttt{or}(\varphi_1/[\textbf{t}],\varphi/[\textbf{t}])$;
%%         \item if $\texttt{all}(\varphi) \in \mathcal{F}$, then $\texttt{all}(\varphi)/[\textbf{t}] = \texttt{all}(\varphi/[\textbf{t}])$ and
%%         \item if $\texttt{ex}(\varphi)\in \mathcal{F}$, then $\texttt{ex}(\varphi)/[\textbf{t}] = \texttt{ex}(\varphi/[\textbf{t}])$.
%%     \end{enumerate}
\end{definition}

Halbach mentions that in situations where it is necessary to specify the exact logical rules in derivations he will use a sequent calculus \cite[p. 29]{halbach:2011}. Since we need a fully syntactical notion of closure under first-order inference, we need to implement a concrete calculus to have an idea of what first-order closure is. We hence implement a notion of sequent calculus derivations of formulae.

\begin{definition}[sequent calculus inference rules]
    Let $\mathcal{L}$ be a formal language, and $Th$ some set of $Th \subseteq \mathcal{S}(\mathcal{L})$ functioning as axioms. Then the inference rules of sequent calculus are
    \begin{enumerate}
        \item $r_{lax} : \mathcal{P}(\mathcal{F}(\mathcal{L}, \mathbb{N}))^2 \to \mathcal{P}(\mathcal{F}(\mathcal{L},\mathbb{N}))^2$ defined by $r_{lax}(\Gamma,\Delta) = (\Gamma \cup \{\varphi\}, \Delta \cup \{\varphi\})$, where $\varphi \in \mathcal{F}(\mathcal{L},\mathbb{N})$,
        \item $r_{tax} : \mathcal{P}(\mathcal{F}(\mathcal{L}, \mathbb{N}))^2 \to \mathcal{P}(\mathcal{F}(\mathcal{L}, \mathbb{N}))^2$ defined by $r_{tax}(\Gamma, \Delta) = (\Gamma, \Delta \cup \{\phi\})$, where $\varphi \in Th$,
        \item PROCEED HERE          
        %% \item $r_{cut} : \mathcal{S}^2 \to \mathcal{S}$ defined by $r_{cut}((\Gamma,\Delta \cup \{\phi\}),(\{\phi\} \cup \Sigma,\Pi))=(\Gamma \cup \Sigma, \Delta \cup \Pi)$,
        %% \item $r_{\land L_1} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\land L_1}((\Gamma \cup \{\phi\}, \Delta))=(\Gamma \cup \{\phi \land \psi\}, \Delta)$,
        %% \item $r_{\land L_2} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\land L_2}((\Gamma \cup \{\psi\}, \Delta))=(\Gamma \cup \{\phi \land \psi\}, \Delta)$,
        %% \item $r_{\lor L} : \mathcal{S}^2 \to \mathcal{S}$ defined by $r_{\lor L}((\Gamma \cup \{\phi\},\Delta),(\Gamma \cup \{\psi\},\Delta))=(\Gamma \cup \{\phi \lor \psi\},\Delta)$,
        %% \item $r_{\to L} : \mathcal{S}^2 \to \mathcal{S}$ defined by $r_{\to L}((\Gamma, \{\phi\} \cup \Delta),(\Sigma \cup \{\psi\},\Pi))=(\Gamma \cup \Sigma \cup \{(\phi \to \psi)\},\Delta \cup \Pi)$,
        %% \item $r_{\neg L} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\neg L}(\Gamma,\{\phi\} \cup \Delta)=(\Gamma \cup \{\neg \phi\},\Delta)$,
        %% \item $r_{\forall L} : \mathcal{S} \to \mathcal{S}$ defined by $r_{\forall L}(\Gamma \cup \{\phi [t/x]\},\Delta)=(\Gamma \cup \{ \forall x \phi \},\Delta)$,

    \end{enumerate}
\end{definition}

\noindent \textcolor{red}{[I haven't reviewed from here on out.]}

\section{Disquotation}\label{subsec:disquotation}
\begin{definition}[conservativity]
    A truth system $...$ [\textcolor{red}{how do you get this symbol?}] in the language $\mathcal{L}_T$ is conservative over a system $\mathcal{S}$ formulated in language $\mathcal{L}$ without the truth predicate if and only if all sentences $s \in \mathcal{L}$ provable by $...$ are also provable by $\mathcal{S}$.
\end{definition}

\begin{lemma}[finite axioms in TB]
    In a proof in \texttt{TB} only finitely many axioms can occur.
\end{lemma}

\begin{proof}
    Let $p$ be a proof in \texttt{TB}. Then, by Definition \verb|\ref{def:formal-proof}|, $p$ is a finite sequence of sentences each of which is an axiom of \texttt{TB} or follows from the preceding sentences according to first-order rules of inference. The amount of axioms the proof contains is less or equal to the total number of sentences. Hence, the number of axioms in the proof should also be finite. 
\end{proof}

\begin{theorem}
    \texttt{TB} is conservative over \texttt{PA}.
\end{theorem}

\begin{proof}
Let $\psi$ be a formula in $\mathcal{L}$ that is provable in TB by a proof $p$. Then, by Lemma \verb|\ref{lem:finit-ax-tb}|, we have that $p$ contains finitely many sentences as axioms. Let $n$ be the number of disquotation sentences occurring as axioms in the proof. Then, every axiom $p$ is either (i) an axiom of \texttt{PA}, or (ii) an instance of the induction schema, or (iii) for some $i \leq n$, a sentence of the form: 
\begin{align*}
    T\ulcorner \varphi_i \urcorner \leftrightarrow \varphi_i.
\end{align*}
As axioms of type (i) and (ii) are sentences of $\mathcal{L}$, we need only show how to transform any given disquotation axiom into a logically equivalent sentence of $\mathcal{L}$. Now, let $\tau(x)$ be the formula: 
\begin{align*}
    (x = \ulcorner \varphi_1 \urcorner \land \varphi_1) \lor ... \lor (x = \ulcorner \varphi_k \urcorner \land \varphi_k).
\end{align*}
By Lemma \verb|\ref{lem:Tphi-eq-tau}|, we have that $T\ulcorner \varphi \urcorner \iff \tau(\ulcorner \varphi \urcorner)$. Hence, we can replace all occurrences of the truth predicate $T$ in the given \texttt{TB}-proof with $\tau$. Then the disquotation ...
\end{proof}

We will here define proof systems for $\texttt{PA}$, $\texttt{PAT}$ and $\texttt{TB}$. As all these theories have to be closed under first-order inference, the rules for deriving formulas from other formulas can be the same for each theory. We hence need to formulate the axioms of these theories and a general notion of first-order provability. 

\begin{definition}[formal proof]
    A formal proof in a logical system $\mathcal{S}$ is a finite sequence of sentences, where each sentence is an axiom of $\mathcal{S}$, an assumption, or follows from the application of one of $\mathcal{S}$'s rules of inference to previous sentences in the sequence (Wikipedia: Formal proof).
\end{definition}

\begin{definition}[provability]
    A formula $\varphi$ is provable in a proof system $\mathcal{S}$ if and only if there exists a formal proof $\mathcal{P}$ in $\mathcal{S}$, such that $\mathcal{P}$ contains no assumptions and $\varphi$ is the last sentence of $\mathcal{P}$.
\end{definition}


