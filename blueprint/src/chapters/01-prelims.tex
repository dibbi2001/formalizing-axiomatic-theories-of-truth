\chapter{Preliminaries}
Section \ref{subsec:notation} will first provide some notes on notation. Then, Section \ref{subsec:language} will focus on the concepts of a first-order language and formulas, Section \ref{subsec:coding} will focus on how formulas can be encoded in natural numbers, Section \ref{subsec:lpa-lt} will discuss the specific languages of $\mathcal{L}$ and $\mathcal{L}_T$, Section \ref{subsec:axiomatization} discusses the axioms of \texttt{PA}, \texttt{PAT} and \texttt{TB}, Section \ref{subsec:proof-theory} will provide the necessary concepts for reasoning about derivations and finally Section \ref{subsec:disquotation} will discuss the concepts and final proof of the conservativity of \texttt{TB} over \texttt{PA}.

\section{Language}\label{subsec:language}
The ordinary definition of a first-order language $\mathcal{L}$ proceeds from the specification of a signature $\mathcal{S}$ and then an inductive definition of the way formulas can be build with elements from $\mathcal{S}$, the set of logical connectives, variables and the quantifiers. See that for any first order language all these elements except the signature are the same. Hence, we could think of a specific first order language as being fully specified by its signature.

\begin{definition}[First-order Language]\label{def:FO-Language}
\lean{FirstOrder.Language}\leanok
  A language is a structure $\langle(F_i)_{i\in \mathbb{N}}, (R_i)_{i\in \mathbb{N}})\rangle$, where $F_i$ is a set of $i$-ary function symbols and $R_i$ a set of $i$-ary predicate symbols.
\end{definition}

Note that this defines a language as consisting only of functions and relations, whereas in philosophical logic it is more conventional that a language also contains a set of constants, like in Negri \& Von Plato \cite{negri:2001}. Observe, however, that constants can be modeled as $0$-ary functions, so this definition of a language does not limit expressive power. By providing concrete sets of function and relation symbols to $F_i$ and $R_i$ we obtain a specific language. So, the language in which our formula \ref{fml:db} is stated can be defined as $\mathcal{L}_{ex} = \langle (F_{ex,i})_{i \in \mathbb{N}}, (R_{ex,i})_{i \in \mathbb{N}} \rangle$, where $(F_{ex,i})_{i \in \mathbb{N}}$ is defined by $F_{ex,0} = \{a\}$ and $F_{ex,1} = \{f\}$ and $(R_{ex,i})_{i \in \mathbb{N}}$ is defined by $R_{ex,1} = \{P, R\}$.

Now, we can use these specifications in \texttt{mathlib}'s implementation of \texttt{Term}s and \texttt{BoundedFormula}s.

\begin{definition}[First-order Term]\label{def:FO-Term}
  \lean{FirstOrder.Language.Term}\leanok
  \uses{def:FO-Language}
    Let $\mathcal{L} = \langle F, R \rangle$ be a first-order language and $\alpha$ a set used to index free variables. Then the set of terms with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{T}(\mathcal{L},\alpha)$ is the smallest set such that
        \begin{enumerate}
            \item $\alpha \subseteq \mathcal{T}(\mathcal{L},\alpha)$ and
            \item for all $i \in \mathbb{N}$, if $f \in F(i)$ and $x_1,...,x_i \in \mathcal{T}(\mathcal{L},\alpha)$, then $f(x_1,...,x_i) \in \mathcal{T}(\mathcal{L},\alpha)$.
        \end{enumerate}
\end{definition}

The concept of \texttt{Term} is used to define the concept \texttt{BoundedFormula}. For its definition we first need the notion of the disjoint union of two sets. Informally this is the union of two sets, where elements are marked with what set they originally come from.
\begin{definition}[$\sqcup$ : Disjoint Union]\label{def:Disjoint-Union}
  \lean{Sum}\leanok
  The disjoint union, denoted $\sqcup$, of two sets $A$ and $B$ is defined as $A \sqcup B = \{(a,k) | (a \in A \wedge k = l) \vee (a \in B \wedge k = r)\}$.
\end{definition}
We shall from here on out refer to $(a,l)$ from a disjoint union of sets by $\#1$ and $(a,r)$ by $\&a$. 

\begin{definition}[First-order BoundedFormula]\label{def:FO-BoundedFormula}
  \lean{FirstOrder.Language.BoundedFormula}\leanok
  \uses{def:FO-Language, def:FO-Term, def:Disjoint-Union}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language, $\alpha$ a set indexing free variables, $n$ the intended number of variables bound by a quantifier and $\mathcal{T}(\mathcal{L}, \alpha \cup \{1,...,n\})$ a set of terms. Then, the set of bounded formulas with respect to these variables $\mathcal{B}(\mathcal{L},\alpha,n)$ is the smallest set such that
    \begin{enumerate}
        \item $\bot \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $t_1,t_2 \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $t_1 = t_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item for all $i \in \mathbb{N}$, if $P \in R_i$ and $t_1,...,t_i \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $P(t_1,...,t_i) \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $f_1,f_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$, then $(f_1 \rightarrow f_2) \in \mathcal{B}(\mathcal{L},\alpha,n)$ and
        \item if $f \in \mathcal{B}(\mathcal{L},\alpha,n+1)$, then $\forall f \in \mathcal{B}(\mathcal{L},\alpha,n)$.
    \end{enumerate}
\end{definition}
Notice that these definitions differ in various ways from classial De Bruijn notation \cite{bruijn:1972}. Firstly, the disjoint union operator in Definition \ref{def:FO-BoundedFormula}'s clauses 2 and 3 guarantees that free variables and variables bound by a quantifier can only be constructed from different sets, whereas in classical De Bruijn all variables are indexed by $\mathbb{Z}$. The reason for such an implementation is that now we can distinguish free variables from bound variable. In that way we enable adding exactly as many distinct variables in sub-formulas of sentences as the amount of quantifiers removed in Definition \ref{def:FO-BoundedFormula}'s recursive step v. Furthermore, free variables can now come from any set, rather than $\mathbb{Z}$, as they are not bound and hence do not have to indicate at what level they are bound. These two notational nuances require a slight rewrite of our example formula \ref{fml:db} to $\forall (\forall(P(\&0) \rightarrow R(f(\&1))) \to (R(\#x_0) \to P(a)))$, where $x_0$ is some element from the relevant type $\alpha$ for indexing free variables.

We can then go on to define the other standard logical operators: $\neg$, $\exists$, $\top$, $\wedge$, $\vee$, $\leftrightarrow$.
\begin{definition}[$\neg$ : Negation]\label{def:FO-Neg}
  \lean{FirstOrder.Language.BoundedFormula.not}\leanok
  \uses{def:FO-BoundedFormula}
  For some set of first-order BoundedFormulas $\mathcal{B}$ we define the negation operation $\neg : \mathcal{B} \to \mathcal{B}$ by $\neg(\varphi) = \varphi \rightarrow \bot$.
\end{definition}

\begin{definition}[$\exists$ : Exists]\label{def:FO-Ex}
  \lean{FirstOrder.Language.BoundedFormula.ex}\leanok
  \uses{def:FO-BoundedFormula, def:FO-Neg}
  For some set of first-order BoundedFormulas $\mathcal{B}(\mathcal{L},\alpha,(n+1))$ we define the exists operation $\exists : \mathcal{B}(\mathcal{L},\alpha,(n + 1)) \to \mathcal{B}(\mathcal{L},\alpha,n)$ by $\exists(\varphi) = \neg \forall \neg \varphi$.
\end{definition}

\begin{definition}[$\top$ : Top]\label{def:Top}
  \lean{FirstOrder.Language.BoundedFormula.not}\leanok
  \uses{def:FO-Neg}
  We define $\top = \neg \bot$.
\end{definition}

\begin{definition}[$\wedge$ : And]\label{def:FO-And}
  \lean{FirstOrder.Language.BoundedFormula.land}\leanok
  \uses{def:FO-Neg, def:FO-BoundedFormula}
  For $\mathcal{B}$ some set of BoundedFormulas we define the function $\wedge : \mathcal{B} \to \mathcal{B} \to \mathcal{B}$ by $\varphi \wedge \psi = \neg (\varphi \supset \neg \psi)$.
\end{definition}

\begin{definition}[$\vee$ : Or]\label{def:FO-Or}
  \lean{FirstOrder.Language.BoundedFormula.lor}\leanok
  \uses{def:FO-Neg,def:FO-BoundedFormula}
  For $\mathcal{B}$ some set of BoundedFormulas we define the function $\vee : \mathcal{B} \to \mathcal{B} \to \mathcal{B}$ by $\varphi \vee \psi = \neg \phi \supset \psi$.
\end{definition}

\begin{definition}[$\leftrightarrow$ : If and Only If]\label{def:FO-Iff}
  \lean{FirstOrder.Language.BoundedFormula.iff}\leanok
  \uses{def:FO-BoundedFormula,def:FO-And}
  For $\mathcal{B}$ some set of BoundedFormulas we define the function $\leftrightarrow : \mathcal{B} \to \mathcal{B} \to \mathcal{B}$ by $\varphi \leftrightarrow \psi = (\varphi \to \psi) \wedge (\psi \to \varphi)$.
\end{definition}

Formulas and sentences can conveniently be defined as a \texttt{BoundedFormula} with all its bound variables bound and a \texttt{BoundedFormula} that is a formula and does not contain free variables respectively.

\begin{definition}[First-order Formula]\label{def:FO-Formula}
  \lean{FirstOrder.Language.Formula}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L}$ be a first-order language and $\alpha$ a set indexing variables. Then the set of formulas with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{F}(\mathcal{L},\alpha)$ is defined as the set of bounded formulas $\mathcal{B}(\mathcal{L},\alpha,0)$.
\end{definition}

A \texttt{Sentence} is then defined as a \texttt{Formula} that has no free variables.

\begin{definition}[First-order Sentence]\label{def:FO-Sentence}
  \lean{FirstOrder.Language.Sentence}\leanok
  \uses{def:FO-Language, def:FO-Formula}
    Let $\mathcal{L}$ be a first-order language. Then the set of sentences with respect to $\mathcal{L}$ denoted $\mathcal{S}(\mathcal{L})$ is defined as the set of formulas $\mathcal{F}(\mathcal{L},\emptyset)$.
\end{definition}

\section{Coding}\label{subsec:coding}
All well-formed formulas of some first-order language are encodable as a natural number, a conventional example of this being Gödel encoding, but as \texttt{mathlib} does not yet feature Gödel encoding we use other native functions that have the same properties. Both \texttt{mathlib}'s namespace \texttt{Term} and \texttt{BoundedFormula} have a functions \texttt{listEncode} that encode \texttt{Term}s and \texttt{BoundedFormula}s as \texttt{List}s respectively. These lists can then be encoded as natural numbers using \texttt{mathlib}'s \texttt{Encodable.encodeList}. To encode some language $\mathcal{L}$ into a natural number these functions require encodings for $\mathcal{L}$'s function and relation symbols. Furthermore, they also require a set for indexing variables that is proved to be encodable and since \texttt{mathlib} natively has a proof of the encodability of natural numbers, we use from here on out $\mathbb{N}$ to index our free variables. Hence we obtain our definitions of \texttt{term\_tonat} and \texttt{formula\_tonat}.

\begin{definition}[Encoding terms from formulas with free variables]\label{def:FV-Term-Enc}
  \lean{Languages.TermEncoding.term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},\mathbb{N} \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[Encoding terms from sentences]\label{def:S-Term-Enc}
  \lean{Languages.TermEncoding.sentence_term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},Empty \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[BoundedFormula with Free Variables to $\mathbb{N}$ Encoding]\label{def:FV-Formula-to-N}
  \lean{Languages.TermEncoding.formula_tonat}\leanok
  \uses{def:FO-Language,def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},\mathbb{N},n) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{formula\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}

\begin{definition}[Sentence to $\mathbb{N}$ Encoding]\label{def:S-To-N}
  \lean{Languages.TermEncoding.sent_tonat}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},Empty,0) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{sent\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}

\section{$\mathcal{L}$ and $\mathcal{L}_T$}\label{subsec:lpa-lt}
We define the language of Peano Arithmetic based on our notion of a language. We hence first need to define a family of function and relation symbols, indexed by their arity. We also include function symbols that stand for some recursively definable logical operators.

\begin{definition}[The Family of Function Symbols for the Language of Peano Arithmetic]\label{def:L-Func}
  \lean{Languages.LPA.Func}\leanok
  We define $(F_{\mathcal{L},i})_{i \in \mathbb{N}}$ by
  \begin{enumerate}
  \item $(F_{\mathcal{L},0}) = \{\texttt{null}\}$,
  \item $(F_{\mathcal{L},1}) = \{S, \underdot{\neg} , \underdot{\forall}, \underdot{\exists}, {^\circ}\}$,
  \item $(F_{\mathcal{L},2}) = \{+,\times, \underdot{\wedge}, \underdot{\vee}, \underdot{\supset}\}$ and
  \item $(F_{\mathcal{L},3}) = \{\underdot{subs}\}$.
  \end{enumerate}
\end{definition}

\begin{definition}[The Family of Relation Symbols for the Language of Peano Arithmetic]\label{def:L-Rel}
  \lean{Languages.LPA.Rel}\leanok
  We define $(R_{\mathcal{L},i})_{i \in \mathbb{N}}$ by \[R_1 = \{Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, \\ Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.\]
\end{definition}

\begin{definition}[$\mathcal{L}$: the Language of Peano Arithmetic with Syntactic Function and Relation Symbols]\label{def:L}
  \lean{Languages.LPA.signature}\leanok
  \uses{def:FO-Language,def:L-Func,def:L-Rel}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L} = \langle (F_{\mathcal{L},i})_{i \in \mathbb{N}}, (R_{\mathcal{L},i})_{i \in \mathbb{N}} \rangle$.
\end{definition}

We define the language of $\mathcal{L}_T$ as the language $\mathcal{L}$ one relation symbol added: $Tr$. Hence its Function symbols are equivalent to that of $\mathcal{L}$ and the relation symbols only feature an extra $Tr$.

\begin{definition}[The Family of Function Symbols for the Language of Peano Arithmetic]\label{def:L_T-Func}
  \lean{Languages.L_T.Func}\leanok
  We define $(F_{\mathcal{L}_T,i})_{i \in \mathbb{N}}$ by
  \begin{enumerate}
  \item $(F_{\mathcal{L},0}) = \{\texttt{null}\}$,
  \item $(F_{\mathcal{L},1}) = \{S, \underdot{\neg} , \underdot{\forall}, \underdot{\exists}, {^\circ}\}$,
  \item $(F_{\mathcal{L},2}) = \{+,\times, \underdot{\wedge}, \underdot{\vee}, \underdot{\supset}\}$ and
  \item $(F_{\mathcal{L},3}) = \{\underdot{subs}\}$.
  \end{enumerate}
\end{definition}

\begin{definition}[The Family of Relation Symbols for the Language of Peano Arithmetic]\label{def:L_T-Rel}
  \lean{Languages.L_T.Rel}\leanok
  We define $(R_{\mathcal{L}_T,i})_{i \in \mathbb{N}}$ by \[R_1 = \{Tr,Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.\]
\end{definition}

\begin{definition}[$\mathcal{L}_T$: the Language of Peano Arithmetic with $Tr$]\label{def:L_T}
  \lean{Languages.L_T.signature}\leanok
  \uses{def:FO-Language,def:L_T-Func,def:L_T-Rel}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L}_T = \langle (F_{\mathcal{L}_T,i})_{i \in \mathbb{N}}, (R_{\mathcal{L}_T,i})_{i \in \mathbb{N}} \rangle$.
\end{definition}

We can now define the concept of numeral in both $\mathcal{L}$ and $\mathcal{L}_T$.
\begin{definition}[$\mathcal{L}$-Numeral Function]\label{def:L-Numeral}
  \lean{Languages.LPA.numeral}\leanok
  \uses{def:L}
  We define the numeral function $num_{\mathcal{L}} : \mathbb{N} \to \mathcal{T}(\mathcal{L},\alpha)$ recursively as
  \begin{enumerate}
  \item $num_{\mathcal{L}}(0) = \texttt{null}$
  \item $num_{\mathcal{L}}(n + 1) = S(num_{\mathcal{L}}(n))$
  \end{enumerate}
\end{definition}

\begin{definition}[$\mathcal{L}_T$-Numeral Function]\label{def:L_T-Numeral}
  \lean{Languages.L_T.numeral}\leanok
  \uses{def:L_T}
  We define the numeral function $num_{\mathcal{L}_T} : \mathbb{N} \to \mathcal{T}(\mathcal{L}_T,\alpha)$ recursively as
  \begin{enumerate}
  \item $num_{\mathcal{L_T}}(0) = \texttt{null}$
  \item $num_{\mathcal{L_T}}(n + 1) = S(num_{\mathcal{L_T}}(n))$
  \end{enumerate}
\end{definition}

Now we have the notion of numeral, we can combine this with our \texttt{tonat} functions to construct an encoding of Terms and BoundedFormulas from $\mathcal{L}$ and $\mathcal{L}_T$ into closed terms in $\mathcal{L}$ and $\mathcal{L}_T$ themselves. We shall denote the numeral corresponding to the code of a BoundedFormula $\varphi$ or Term $t$ by $\ulcorner \varphi \urcorner$ and $\ulcorner t \urcorner$ respectively. 

\section{Axiomatization}\label{subsec:axiomatization}
Once we have a formal language and specification of its formulas, we can define the theories we want to reason about. In \texttt{mathlib} theories are defined by their axioms, so constructing a theory is equivalent to specifying its axioms. 

\begin{definition}[Theory]\label{def:FO-Theory}
  \lean{FirstOrder.Language.Theory}\leanok
  \uses{def:FO-Language,def:FO-Sentence}
  Let $\mathcal{L}$ be a formal language and $S_{\mathcal{L}}$ its associated set of sentences. Then, a theory of $\mathcal{L}$ is a set of sentences $T_{\mathcal{L}}$ such that $T_{\mathcal{L}} \subseteq S_{\mathcal{L}}$.
\end{definition}

We can hence use the notions of $\mathcal{L}$ and $\mathcal{L}_T$ to construct the theories of Syntax Theory, Peano Arithmetic \texttt{PA}, Peano Arithmetic with T \texttt{PAT} and Peano Arithmetic with T and Tarski Biconditionals \texttt{TB}. For Syntax Theory we provide the primitive recursive logical operations as axioms.
\subsubsection{Syntax Axioms}
\begin{definition}[$\underdot{\neg}$: Syntactic Negation Operator Axioms]\label{def:Syntactic-Neg}
  \lean{SyntaxAxioms.neg_repres}\leanok
  \uses{def:FO-Language,def:L,def:FO-Neg,def:L-Numeral}
  The meaning of the syntactic negation operator $\underdot{\neg}$ is captured by the axiom scheme $\mathbb{N})(\underdot{\neg} \ulcorner \varphi \urcorner = \ulcorner \neg \varphi \urcorner)$, where $\varphi \in \mathcal{F}(\mathcal{L},\mathbb{N})$. 
\end{definition}

\begin{definition}[$\underdot{\wedge}$: Syntactic Conjunction Operator Axiom]\label{def:Syntactic-Conj}
  \lean{SyntaxAxioms.conj_repres}\leanok
  \uses{def:FO-Language,def:L,def:FO-And,def:L-Numeral,def:FV-Formula-to-N}
  The meaning of the syntactic conjunction operator $\underdot{\wedge}$ is captured by the axiom scheme $(\ulcorner \varphi \urcorner \underdot{\wedge} \ulcorner \psi \urcorner) = (\ulcorner \varphi \wedge \psi \urcorner)$, where $\varphi, \psi \in \mathcal{F}(\mathcal{L},\mathbb{N})$.
\end{definition}

\begin{definition}[$\underdot{\vee}$: Syntactic Disjunction Operator Axiom Scheme]\label{def:Syntactic-Disj}
  \lean{SyntaxAxioms.disj_repres}\leanok
  \uses{def:FO-Language,def:L,def:FO-Or,def:L-Numeral,def:FV-Formula-to-N}
  The meaning of the syntactic disjunction operator $\underdot{\vee}$ is captured by the axiom scheme $(\ulcorner \varphi \urcorner \underdot{\vee} \ulcorner \psi \urcorner = (\ulcorner \varphi \wedge \psi \urcorner)$, where $\varphi, \psi \in \mathcal{F}(\mathcal{L},\mathbb{N})$.
\end{definition}

\begin{definition}[$\underdot{\supset}$: Syntactic Condition Operator Axiom Scheme]\label{def:Syntactic-Cond}
  \lean{SyntaxAxioms.cond_repres}\leanok
  \uses{def:FO-BoundedFormula,def:L}
  The meaning of the syntactic conditional operator $\underdot{\supset}$ is captured by the axiom scheme $(\ulcorner \varphi \urcorner) \underdot{\supset} \ulcorner \psi \urcorner) = (\ulcorner \phi \supset \psi)$, where $\varphi, \psi \in \mathcal{F}(\mathcal{L},\mathbb{N})$.
\end{definition}

-------------------------------------here should go more syntax axioms-----------------------------------

\begin{definition}[Syntax Theory]\label{def:Syntax-Theory}
  \lean{SyntaxTheory.syntax_theory_l}\leanok
  \uses{def:FO-Theory,def:L}
  We define Syntax Theory as the theory containg all the instances of the axiom schemas for $\underdot{\neg}$, $\underdot{\wedge}$, $\underdot{\vee}$, $\underdot{\supset}$, etc.
\end{definition}

The system of Peano arithmetic contains the defining equations for zero, successor, addition, and multiplication. We first provide the finite theory of the first 6 Peano axioms.
\begin{definition}[The First 6 Axioms of Peano Arithmetic]\label{def:PA-Axioms}
  \lean{PA.peano_axioms}\leanok
  \uses{def:FO-Language,def:FO-Theory,def:L}
    The theory of the first 6 axioms of Peano Arithmetic \texttt{PA-axioms} is defined as the smallest theory $X$ such that
    \begin{enumerate}
        \item $\forall \neg (\&0 = S(\&0) \in X$, 
        \item $\forall \forall (S(\&1) = S(\&0) \rightarrow \&1 = \&0) \in X$,
        \item $\forall (\&0 + \texttt{null} = \&0) \in X$,
        \item $\forall \forall (\&1 + S(\&0) = S(\&1 + \&0)) \in X$,
        \item $\forall (\&1 \cdot \texttt{null} = \texttt{null}) \in X$ and
        \item $\forall  \forall (\&1 \cdot S(\&0) = \&1 \cdot \&0 + \&1) \in X$.
    \end{enumerate}
\end{definition}

Then we define \texttt{PA} as the union of the first 6 Peano axioms and all the instances of the induction scheme for \texttt{PA}.
\begin{definition}[\texttt{PA}: The Theory of Peano Arithmetic]\label{def:PA}
  \lean{PA.peano_arithmetic}\leanok
  \uses{def:PA-Axioms,def:FO-Formula,def:L}
  We define \texttt{PA} as the theory $\texttt{PA-axioms} \cup \{φ | ∃ψ \in \mathcal{F}(\mathcal{L},{0}) : φ = ([ψ(\texttt{null}) \wedge ∀\langle ψ(\&0) \supset ψ(S(\&0)) \rangle ] \supset ∀ψ(\&0))\}$.
\end{definition}

\begin{definition}[\texttt{PAT}]\label{def:PAT}
  \lean{PAT.pat}\leanok
  \uses{def:PA-Axioms,def:FO-Formula,def:L}
    We define \texttt{PAT} as the theory $\texttt{PA-axioms} \cup \{φ | ∃ψ \in \mathcal{F}(\mathcal{L}_T,{0}) : φ = ([ψ(\texttt{null}) \wedge ∀\langle ψ(\&0) \supset ψ(S(\&0)) \rangle ] \supset ∀ψ(\&0))\}$.
\end{definition}

\begin{definition}[\texttt{TB}]\label{def:TB}
  \lean{TB.tarski_biconditionals}\leanok
  \uses{def:PAT,def:FO-Sentence}
    We define \texttt{TB} as $\texttt{PAT} \cup \{φ | ∃ψ \in \mathcal{S}(\mathcal{L}) : φ = T(⌜ψ⌝) \leftrightarrow ψ\}$.
\end{definition}

\section{Proof Theory}\label{subsec:proof-theory}
For own notion of proof we use a sequent calculus: G3cp + G3c (see \cite{negri:2001} pages 49 and 67 respectively) and an axiom for adding axioms from theories.
\begin{definition}[Sequent Calculus]\label{def:Seq-Calc}
  \lean{Calculus.Derivation}
    Let $\mathcal{L}$ be a formal language, and $Th$ some set of $Th \subseteq \mathcal{S}(\mathcal{L})$ functioning as axioms. Then the inference rules of sequent calculus are

\noindent \textbf{Theoretical Axiom:}

if $A \in Th$ then $\Gamma \Rightarrow A, \Delta$

\begin{center}
    \textbf{G3cp}
\end{center}
\noindent \textbf{Logical Axiom:}

$\Gamma, P \Rightarrow P, \Delta$

\noindent \textbf{Logical Rules:}
\begin{multicols}{2}
\[
\frac{\Gamma \Rightarrow A, \Delta \quad \Gamma \Rightarrow B, \Delta}{\Gamma \Rightarrow A \land B, \Delta}\tag{$R\land$}
\]

\[
\frac{\Gamma, A, B \Rightarrow \Delta}{\Gamma, A \land B \Rightarrow \Delta}\tag{$L\land$}
\]

\[
\frac{\Gamma \Rightarrow A, B, \Delta}{\Gamma \Rightarrow A \lor B, \Delta}\tag{$R\lor$}
\]

\[
\frac{\Gamma, A \Rightarrow \Delta \quad \Gamma, B \Rightarrow \Delta}{\Gamma, A \lor B \Rightarrow \Delta}\tag{$L\lor$}
\]

\[
\frac{\Gamma, A \Rightarrow B, \Delta}{\Gamma \Rightarrow A \supset B, \Delta}\tag{$R\supset$}
\]

\[
\frac{\Gamma \Rightarrow A, \Delta \quad \Gamma, B \Rightarrow \Delta}{\Gamma, A \supset B \Rightarrow \Delta}\tag{$L\supset$}
\]

\[
\frac{}{\bot, \Gamma \Rightarrow \Delta}\tag{$L\bot$}
\]

\end{multicols}

\begin{center}
    \textbf{G3c}
\end{center}
\begin{multicols}{2}

\[
\frac{\Gamma \Rightarrow A[y/x], \Delta}{\Gamma \Rightarrow \forall x A, \Delta}\tag{$R\forall$}
\]

\[
\frac{\Gamma, A[t/x], \forall x A \Rightarrow \Delta}{\Gamma, \forall x A \Rightarrow \Delta}\tag{$L\forall$}
\]

\[
\frac{\Gamma, A[y/x] \Rightarrow \Delta}{\Gamma, \exists x A \Rightarrow \Delta}\tag{$L\exists$}
\]

\[
\frac{\Gamma \Rightarrow \exists x A, A[t/x], \Delta}{\Gamma \Rightarrow \exists x A, \Delta}\tag{$R\exists$}
\]

\end{multicols}

\end{definition}

--------------------------------------------------------------

\section{Disquotation}\label{subsec:disquotation}
\begin{definition}[conservativity]
    A truth system $...$  in the language $\mathcal{L}_T$ is conservative over a system $\mathcal{S}$ formulated in language $\mathcal{L}$ without the truth predicate if and only if all sentences $s \in \mathcal{L}$ provable by $...$ are also provable by $\mathcal{S}$.
\end{definition}

\begin{lemma}[finite axioms in TB]
    In a proof in \texttt{TB} only finitely many axioms can occur.
\end{lemma}

\begin{proof}
    Let $p$ be a proof in \texttt{TB}. Then, by Definition \verb|\ref{def:formal-proof}|, $p$ is a finite sequence of sentences each of which is an axiom of \texttt{TB} or follows from the preceding sentences according to first-order rules of inference. The amount of axioms the proof contains is less or equal to the total number of sentences. Hence, the number of axioms in the proof should also be finite. 
\end{proof}

\begin{theorem}
    \texttt{TB} is conservative over \texttt{PA}.
\end{theorem}

\begin{proof}
Let $\psi$ be a formula in $\mathcal{L}$ that is provable in TB by a proof $p$. Then, by Lemma \verb|\ref{lem:finit-ax-tb}|, we have that $p$ contains finitely many sentences as axioms. Let $n$ be the number of disquotation sentences occurring as axioms in the proof. Then, every axiom $p$ is either (i) an axiom of \texttt{PA}, or (ii) an instance of the induction schema, or (iii) for some $i \leq n$, a sentence of the form: 
\begin{align*}
    T\ulcorner \varphi_i \urcorner \leftrightarrow \varphi_i.
\end{align*}
As axioms of type (i) and (ii) are sentences of $\mathcal{L}$, we need only show how to transform any given disquotation axiom into a logically equivalent sentence of $\mathcal{L}$. Now, let $\tau(x)$ be the formula: 
\begin{align*}
    (x = \ulcorner \varphi_1 \urcorner \land \varphi_1) \lor ... \lor (x = \ulcorner \varphi_k \urcorner \land \varphi_k).
\end{align*}
By Lemma \verb|\ref{lem:Tphi-eq-tau}|, we have that $T\ulcorner \varphi \urcorner \iff \tau(\ulcorner \varphi \urcorner)$. Hence, we can replace all occurrences of the truth predicate $T$ in the given \texttt{TB}-proof with $\tau$. Then the disquotation ...
\end{proof}

We will here define proof systems for $\texttt{PA}$, $\texttt{PAT}$ and $\texttt{TB}$. As all these theories have to be closed under first-order inference, the rules for deriving formulas from other formulas can be the same for each theory. We hence need to formulate the axioms of these theories and a general notion of first-order provability. 

\begin{definition}[formal proof]
    A formal proof in a logical system $\mathcal{S}$ is a finite sequence of sentences, where each sentence is an axiom of $\mathcal{S}$, an assumption, or follows from the application of one of $\mathcal{S}$'s rules of inference to previous sentences in the sequence (Wikipedia: Formal proof).
\end{definition}

\begin{definition}[provability]
    A formula $\varphi$ is provable in a proof system $\mathcal{S}$ if and only if there exists a formal proof $\mathcal{P}$ in $\mathcal{S}$, such that $\mathcal{P}$ contains no assumptions and $\varphi$ is the last sentence of $\mathcal{P}$.
\end{definition}


