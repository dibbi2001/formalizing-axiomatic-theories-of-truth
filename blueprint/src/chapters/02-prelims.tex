\chapter{Preliminaries}
\section{Language}\label{subsec:language}
The ordinary definition of a first-order language $\mathcal{L}$ proceeds from the specification of a signature $\mathcal{S}$ and then an inductive definition of the way formulas can be build with elements from $\mathcal{S}$, the set of logical connectives, variables and the quantifiers. See that for any first order language all these elements except the signature are the same. Hence, we could think of a specific first order language as being fully specified by its signature.

\begin{definition}[First-order Language]\label{def:FO-Language}
\lean{FirstOrder.Language}\leanok
  A language is a structure $\langle(F_i)_{i\in \mathbb{N}}, (R_i)_{i\in \mathbb{N}})\rangle$, where $F_i$ is a set of $i$-ary function symbols and $R_i$ a set of $i$-ary predicate symbols.
\end{definition}

Note that this defines a language as consisting only of functions and relations, whereas in philosophical logic it is more conventional that a language also contains a set of constants, like in Negri \& Von Plato \cite{negri:2001}. Observe, however, that constants can be modeled as $0$-ary functions, so this definition of a language does not limit expressive power. By providing concrete sets of function and relation symbols to $F_i$ and $R_i$ we obtain a specific language. So, the language in which our formula \ref{fml:db} is stated can be defined as $\mathcal{L}_{ex} = \langle (F_{ex,i})_{i \in \mathbb{N}}, (R_{ex,i})_{i \in \mathbb{N}} \rangle$, where $(F_{ex,i})_{i \in \mathbb{N}}$ is defined by $F_{ex,0} = \{a\}$ and $F_{ex,1} = \{f\}$ and $(R_{ex,i})_{i \in \mathbb{N}}$ is defined by $R_{ex,1} = \{P, R\}$.

Now, we can use these specifications in \texttt{mathlib}'s implementation of \texttt{Term}s and \texttt{BoundedFormula}s.

\begin{definition}[First-order Term]\label{def:FO-Term}
  \lean{FirstOrder.Language.Term}\leanok
  \uses{def:FO-Language}
    Let $\mathcal{L} = \langle F, R \rangle$ be a first-order language and $\alpha$ a set used to index free variables. Then the set of terms with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{T}(\mathcal{L},\alpha)$ is the smallest set such that
        \begin{enumerate}
            \item $\alpha \subseteq \mathcal{T}(\mathcal{L},\alpha)$ and
            \item for all $i \in \mathbb{N}$, if $f \in F(i)$ and $x_1,...,x_i \in \mathcal{T}(\mathcal{L},\alpha)$, then $f(x_1,...,x_i) \in \mathcal{T}(\mathcal{L},\alpha)$.
        \end{enumerate}
\end{definition}

The concept of \texttt{Term} is used to define the concept \texttt{BoundedFormula}. For its definition we first need the notion of the disjoint union of two sets. Informally this is the union of two sets, where elements are marked with what set they originally come from.
\begin{definition}[$\sqcup$ : Disjoint Union]\label{def:Disjoint-Union}
  \lean{Sum}\leanok
  The disjoint union, denoted $\sqcup$, of two sets $A$ and $B$ is defined as $A \sqcup B = \{(a,k) | (a \in A \wedge k = l) \vee (a \in B \wedge k = r)\}$.
\end{definition}
We shall from here on out refer to $(a,l)$ from a disjoint union of sets by $\#1$ and $(a,r)$ by $\&a$. 

\begin{definition}[First-order BoundedFormula]\label{def:FO-BoundedFormula}
  \lean{FirstOrder.Language.BoundedFormula}\leanok
  \uses{def:FO-Language, def:FO-Term, def:Disjoint-Union}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language, $\alpha$ a set indexing free variables, $n$ the intended number of variables bound by a quantifier and $\mathcal{T}(\mathcal{L}, \alpha \cup \{1,...,n\})$ a set of terms. Then, the set of bounded formulas with respect to these variables $\mathcal{B}(\mathcal{L},\alpha,n)$ is the smallest set such that
    \begin{enumerate}
        \item $\bot \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $t_1,t_2 \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $t_1 = t_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item for all $i \in \mathbb{N}$, if $P \in R_i$ and $t_1,...,t_i \in \mathcal{T}(\mathcal{L}, \alpha \sqcup \{0,...,n-1\})$, then $P(t_1,...,t_i) \in \mathcal{B}(\mathcal{L},\alpha,n)$,
        \item if $f_1,f_2 \in \mathcal{B}(\mathcal{L},\alpha,n)$, then $(f_1 \rightarrow f_2) \in \mathcal{B}(\mathcal{L},\alpha,n)$ and
        \item if $f \in \mathcal{B}(\mathcal{L},\alpha,n+1)$, then $\forall f \in \mathcal{B}(\mathcal{L},\alpha,n)$.
    \end{enumerate}
\end{definition}
Notice that these definitions differ in various ways from classial De Bruijn notation \cite{bruijn:1972}. Firstly, the disjoint union operator in Definition \ref{def:FO-BoundedFormula}'s clauses 2 and 3 guarantees that free variables and variables bound by a quantifier can only be constructed from different sets, whereas in classical De Bruijn all variables are indexed by $\mathbb{Z}$. The reason for such an implementation is that now we can distinguish free variables from bound variable. In that way we enable adding exactly as many distinct variables in sub-formulas of sentences as the amount of quantifiers removed in Definition \ref{def:FO-BoundedFormula}'s recursive step v. Furthermore, free variables can now come from any set, rather than $\mathbb{Z}$, as they are not bound and hence do not have to indicate at what level they are bound. These two notational nuances require a slight rewrite of our example formula \ref{fml:db} to $\forall (\forall(P(\&0) \rightarrow R(f(\&1))) \to (R(\#x_0) \to P(a)))$, where $x_0$ is some element from the relevant type $\alpha$ for indexing free variables.

We can then go on to define the other standard logical operators: $\neg$, $\exists$, $\top$, $\wedge$, $\vee$, $\leftrightarrow$.
\begin{definition}[$\neg$ : Negation]\label{def:FO-Neg}
  \lean{FirstOrder.Language.BoundedFormula.not}\leanok
  \uses{def:FO-BoundedFormula}
  For some set of first-order BoundedFormulas $\mathcal{B}$ we define the negation operation $\neg : \mathcal{B} \to \mathcal{B}$ by $\neg(\varphi) = \varphi \rightarrow \bot$.
\end{definition}

\begin{definition}[$\exists$ : Exists]\label{def:FO-Ex}
  \lean{FirstOrder.Language.BoundedFormula.ex}\leanok
  \uses{def:FO-BoundedFormula, def:FO-Neg}
  For some set of first-order BoundedFormulas $\mathcal{B}(\mathcal{L},\alpha,(n+1))$ we define the exists operation $\exists : \mathcal{B}(\mathcal{L},\alpha,(n + 1)) \to \mathcal{B}(\mathcal{L},\alpha,n)$ by $\exists(\varphi) = \neg \forall \neg \varphi$.
\end{definition}

\begin{definition}[$\top$ : Top]\label{def:Top}
  \lean{FirstOrder.Language.BoundedFormula.not}\leanok
  \uses{def:FO-Neg}
  We define $\top = \neg \bot$.
\end{definition}

\begin{definition}[$\wedge$ : And]\label{def:FO-And}
  \lean{FirstOrder.Language.BoundedFormula.land}\leanok
  \uses{def:FO-Neg, def:FO-BoundedFormula}
  For $\mathcal{B}$ some set of BoundedFormulas we define the function $\wedge : \mathcal{B} \to \mathcal{B} \to \mathcal{B}$ by $\varphi \wedge \psi = \neg (\varphi \supset \neg \psi)$.
\end{definition}

\begin{definition}[$\vee$ : Or]\label{def:FO-Or}
  \lean{FirstOrder.Language.BoundedFormula.lor}\leanok
  \uses{def:FO-Neg,def:FO-BoundedFormula}
  For $\mathcal{B}$ some set of BoundedFormulas we define the function $\vee : \mathcal{B} \to \mathcal{B} \to \mathcal{B}$ by $\varphi \vee \psi = \neg \phi \supset \psi$.
\end{definition}

\begin{definition}[$\leftrightarrow$ : If and Only If]\label{def:FO-Iff}
  \lean{FirstOrder.Language.BoundedFormula.iff}\leanok
  \uses{def:FO-BoundedFormula,def:FO-And}
  For $\mathcal{B}$ some set of BoundedFormulas we define the function $\leftrightarrow : \mathcal{B} \to \mathcal{B} \to \mathcal{B}$ by $\varphi \leftrightarrow \psi = (\varphi \to \psi) \wedge (\psi \to \varphi)$.
\end{definition}

Formulas and sentences can conveniently be defined as a \texttt{BoundedFormula} with all its bound variables bound and a \texttt{BoundedFormula} that is a formula and does not contain free variables respectively.

\begin{definition}[First-order Formula]\label{def:FO-Formula}
  \lean{FirstOrder.Language.Formula}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L}$ be a first-order language and $\alpha$ a set indexing variables. Then the set of formulas with respect to $\mathcal{L}$ and $\alpha$ denoted $\mathcal{F}(\mathcal{L},\alpha)$ is defined as the set of bounded formulas $\mathcal{B}(\mathcal{L},\alpha,0)$.
\end{definition}

A \texttt{Sentence} is then defined as a \texttt{Formula} that has no free variables.

\begin{definition}[First-order Sentence]\label{def:FO-Sentence}
  \lean{FirstOrder.Language.Sentence}\leanok
  \uses{def:FO-Language, def:FO-Formula}
    Let $\mathcal{L}$ be a first-order language. Then the set of sentences with respect to $\mathcal{L}$ denoted $\mathcal{S}(\mathcal{L})$ is defined as the set of formulas $\mathcal{F}(\mathcal{L},\emptyset)$.
\end{definition}

\section{Coding}\label{subsec:coding}
All well-formed formulas of some first-order language are encodable as a natural number, a conventional example of this being Gödel encoding, but as \texttt{mathlib} does not yet feature Gödel encoding we use other native functions that have the same properties. Both \texttt{mathlib}'s namespace \texttt{Term} and \texttt{BoundedFormula} have a functions \texttt{listEncode} that encode \texttt{Term}s and \texttt{BoundedFormula}s as \texttt{List}s respectively. These lists can then be encoded as natural numbers using \texttt{mathlib}'s \texttt{Encodable.encodeList}. To encode some language $\mathcal{L}$ into a natural number these functions require encodings for $\mathcal{L}$'s function and relation symbols. Furthermore, they also require a set for indexing variables that is proved to be encodable and since \texttt{mathlib} natively has a proof of the encodability of natural numbers, we use from here on out $\mathbb{N}$ to index our free variables. Hence we obtain our definitions of \texttt{term\_tonat} and \texttt{formula\_tonat}.

\begin{definition}[Encoding terms from formulas with free variables]\label{def:FV-Term-Enc}
  \lean{Languages.TermEncoding.term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},\mathbb{N} \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[Encoding terms from sentences]\label{def:S-Term-Enc}
  \lean{Languages.TermEncoding.sentence_term_tonat}\leanok
  \uses{def:FO-Language,def:FO-Term}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number. Then the encoding function $\texttt{term\_tonat} : \mathcal{T}(\mathcal{L},Empty \cup \{1,...,n\}) \to \mathbb{N}$ is defined as 
    \begin{align*}  
        \texttt{term\_tonat}(t) = \texttt{Encodable.encodeList}(\texttt{Term.listEncode}(t)).
    \end{align*}
\end{definition}

\begin{definition}[BoundedFormula with Free Variables to $\mathbb{N}$ Encoding]\label{def:FV-Formula-to-N}
  \lean{Languages.TermEncoding.formula_tonat}\leanok
  \uses{def:FO-Language,def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},\mathbb{N},n) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{formula\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}

\begin{definition}[Sentence to $\mathbb{N}$ Encoding]\label{def:S-To-N}
  \lean{Languages.TermEncoding.sent_tonat}\leanok
  \uses{def:FO-Language, def:FO-BoundedFormula}
    Let $\mathcal{L} = \langle (F_i)_{i \in \mathbb{N}}, (R_i)_{i \in \mathbb{N}} \rangle$ be a first-order language and let $n$ be a natural number. Assume furthermore that for all $i \in \mathbb{N}$ all $f \in F_i$ have a unique associated natural number and that for all $i \in \mathbb{N}$ all $r \in R_i$ have a unique associated natural number. Then the encoding function $\texttt{formula\_tonat} : \mathcal{B}(\mathcal{L},Empty,0) \to \mathbb{N}$ is defined as 
    \begin{align*}
        \texttt{sent\_tonat}(\varphi) = \texttt{Encodable.encodeList}(\texttt{BoundedFormula.listEncode}(\varphi)).
    \end{align*}
\end{definition}

\section{$\mathcal{L}$ and $\mathcal{L}_T$}\label{subsec:lpa-lt}
We define the language of Peano Arithmetic based on our notion of a language. We hence first need to define a family of function and relation symbols, indexed by their arity. We also include function symbols that stand for some recursively definable logical operators.

\begin{definition}[The Family of Function Symbols for the Language of Peano Arithmetic]\label{def:L-Func}
  \lean{Languages.LPA.Func}\leanok
  We define $(F_{\mathcal{L},i})_{i \in \mathbb{N}}$ by
  \begin{enumerate}
  \item $(F_{\mathcal{L},0}) = \{\texttt{null}\}$,
  \item $(F_{\mathcal{L},1}) = \{S, \underdot{\neg} , \underdot{\forall}, \underdot{\exists}, {^\circ}\}$,
  \item $(F_{\mathcal{L},2}) = \{+,\times, \underdot{\wedge}, \underdot{\vee}, \underdot{\supset}\}$ and
  \item $(F_{\mathcal{L},3}) = \{\underdot{subs}\}$.
  \end{enumerate}
\end{definition}

\begin{definition}[The Family of Relation Symbols for the Language of Peano Arithmetic]\label{def:L-Rel}
  \lean{Languages.LPA.Rel}\leanok
  We define $(R_{\mathcal{L},i})_{i \in \mathbb{N}}$ by \[R_1 = \{Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, \\ Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.\]
\end{definition}

\begin{definition}[$\mathcal{L}$: the Language of Peano Arithmetic with Syntactic Function and Relation Symbols]\label{def:L}
  \lean{Languages.LPA.signature}\leanok
  \uses{def:FO-Language,def:L-Func,def:L-Rel}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L} = \langle (F_{\mathcal{L},i})_{i \in \mathbb{N}}, (R_{\mathcal{L},i})_{i \in \mathbb{N}} \rangle$.
\end{definition}

We define the language of $\mathcal{L}_T$ as the language $\mathcal{L}$ one relation symbol added: $Tr$. Hence its Function symbols are equivalent to that of $\mathcal{L}$ and the relation symbols only feature an extra $Tr$.

\begin{definition}[The Family of Function Symbols for the Language of Peano Arithmetic]\label{def:L_T-Func}
  \lean{Languages.L_T.Func}\leanok
  We define $(F_{\mathcal{L}_T,i})_{i \in \mathbb{N}}$ by
  \begin{enumerate}
  \item $(F_{\mathcal{L},0}) = \{\texttt{null}\}$,
  \item $(F_{\mathcal{L},1}) = \{S, \underdot{\neg} , \underdot{\forall}, \underdot{\exists}, {^\circ}\}$,
  \item $(F_{\mathcal{L},2}) = \{+,\times, \underdot{\wedge}, \underdot{\vee}, \underdot{\supset}\}$ and
  \item $(F_{\mathcal{L},3}) = \{\underdot{subs}\}$.
  \end{enumerate}
\end{definition}

\begin{definition}[The Family of Relation Symbols for the Language of Peano Arithmetic]\label{def:L_T-Rel}
  \lean{Languages.L_T.Rel}\leanok
  We define $(R_{\mathcal{L}_T,i})_{i \in \mathbb{N}}$ by \[R_1 = \{Tr,Variable, Constant, ClosedTerm, Term, Formula_{\mathcal{L}}, Sentence_{\mathcal{L}}, Formula_{\mathcal{L}_T}, Sentence_{\mathcal{L}_T}\}.\]
\end{definition}

\begin{definition}[$\mathcal{L}_T$: the Language of Peano Arithmetic with $Tr$]\label{def:L_T}
  \lean{Languages.L_T.signature}\leanok
  \uses{def:FO-Language,def:L_T-Func,def:L_T-Rel}
    The language of Peano arithmetic including syntactic functions and predicates is the first-order language $\mathcal{L}_T = \langle (F_{\mathcal{L}_T,i})_{i \in \mathbb{N}}, (R_{\mathcal{L}_T,i})_{i \in \mathbb{N}} \rangle$.
\end{definition}

We can now define the concept of numeral in both $\mathcal{L}$ and $\mathcal{L}_T$.
\begin{definition}[$\mathcal{L}$-Numeral Function]\label{def:L-Numeral}
  \lean{Languages.LPA.numeral}\leanok
  \uses{def:L}
  We define the numeral function $num_{\mathcal{L}} : \mathbb{N} \to \mathcal{T}(\mathcal{L},\alpha)$ recursively as
  \begin{enumerate}
  \item $num_{\mathcal{L}}(0) = \texttt{null}$
  \item $num_{\mathcal{L}}(n + 1) = S(num_{\mathcal{L}}(n))$
  \end{enumerate}
\end{definition}

\begin{definition}[$\mathcal{L}_T$-Numeral Function]\label{def:L_T-Numeral}
  \lean{Languages.L_T.numeral}\leanok
  \uses{def:L_T}
  We define the numeral function $num_{\mathcal{L}_T} : \mathbb{N} \to \mathcal{T}(\mathcal{L}_T,\alpha)$ recursively as
  \begin{enumerate}
  \item $num_{\mathcal{L_T}}(0) = \texttt{null}$
  \item $num_{\mathcal{L_T}}(n + 1) = S(num_{\mathcal{L_T}}(n))$
  \end{enumerate}
\end{definition}

Now we have the notion of numeral, we can combine this with our \texttt{tonat} functions to construct an encoding of Terms and BoundedFormulas from $\mathcal{L}$ and $\mathcal{L}_T$ into closed terms in $\mathcal{L}$ and $\mathcal{L}_T$ themselves. We shall denote the numeral corresponding to the code of a BoundedFormula $\varphi$ or Term $t$ by $\ulcorner \varphi \urcorner$ and $\ulcorner t \urcorner$ respectively.


